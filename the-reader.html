<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="The Reader">
<link rel="apple-touch-icon" href="apple-touch-icon.png">
<link rel="manifest" href="manifest.json">
<title>The Reader</title>
<!-- Async Google Fonts with offline system fallbacks -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Newsreader:ital,opsz,wght@0,6..72,300;0,6..72,400;0,6..72,500;0,6..72,600;1,6..72,400&family=Literata:ital,opsz,wght@0,7..72,300;0,7..72,400;0,7..72,500;0,7..72,600;1,7..72,400&family=Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;1,8..60,400&family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400&family=Crimson+Pro:ital,wght@0,300;0,400;0,500;0,600;1,400&family=DM+Sans:ital,wght@0,400;0,500;0,600;1,400&display=swap" media="print" onload="this.media='all'">
<noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Newsreader:ital,opsz,wght@0,6..72,300;0,6..72,400;0,6..72,500;0,6..72,600;1,6..72,400&family=Literata:ital,opsz,wght@0,7..72,300;0,7..72,400;0,7..72,500;0,7..72,600;1,7..72,400&family=Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;1,8..60,400&family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400&family=Crimson+Pro:ital,wght@0,300;0,400;0,500;0,600;1,400&family=DM+Sans:ital,wght@0,400;0,500;0,600;1,400&display=swap"></noscript>
<style>
/* Offline system font fallbacks */
@font-face { font-family: 'DM Sans'; font-style: normal; font-weight: 400 500 600; src: local('SF Pro Text'), local('Helvetica Neue'), local('Segoe UI'); }
@font-face { font-family: 'DM Sans'; font-style: italic; font-weight: 400; src: local('SF Pro Text'), local('Helvetica Neue'), local('Segoe UI'); }
@font-face { font-family: 'Newsreader'; font-style: normal; font-weight: 300 400 500 600; src: local('Georgia'), local('Iowan Old Style'), local('Palatino'); }
@font-face { font-family: 'Newsreader'; font-style: italic; font-weight: 400; src: local('Georgia'), local('Iowan Old Style'), local('Palatino'); }
@font-face { font-family: 'Literata'; font-style: normal; font-weight: 300 400 500 600; src: local('Charter'), local('Georgia'), local('Iowan Old Style'); }
@font-face { font-family: 'Literata'; font-style: italic; font-weight: 400; src: local('Charter'), local('Georgia'), local('Iowan Old Style'); }
@font-face { font-family: 'EB Garamond'; font-style: normal; font-weight: 400 500 600; src: local('Garamond'), local('Apple Garamond'), local('Georgia'); }
@font-face { font-family: 'EB Garamond'; font-style: italic; font-weight: 400; src: local('Garamond'), local('Apple Garamond'), local('Georgia'); }
@font-face { font-family: 'Source Serif 4'; font-style: normal; font-weight: 300 400 600; src: local('Source Serif Pro'), local('Georgia'), local('Palatino'); }
@font-face { font-family: 'Source Serif 4'; font-style: italic; font-weight: 400; src: local('Source Serif Pro'), local('Georgia'), local('Palatino'); }
@font-face { font-family: 'Crimson Pro'; font-style: normal; font-weight: 300 400 500 600; src: local('Crimson Text'), local('Georgia'), local('Times New Roman'); }
@font-face { font-family: 'Crimson Pro'; font-style: italic; font-weight: 400; src: local('Crimson Text'), local('Georgia'), local('Times New Roman'); }
</style>
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  height: 100%; width: 100%;
  overflow: hidden;
  -webkit-overflow-scrolling: touch;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  touch-action: manipulation;
}
:root {
  --bg: #F0E6D3; --surface: #F8F1E4; --text: #2C2416;
  --text2: #7A6E5D; --border: #D4C9B8; --accent: #8B7355;
  --accent2: #6E5A42; --hl: rgba(218,185,107,0.4);
  --filter: sepia(20%) saturate(85%) brightness(96%) contrast(93%);
  --bar-bg: rgba(248,241,228,0.92); --bar-border: rgba(212,201,184,0.6);
  --shadow: rgba(44,36,22,0.08);
  --st: env(safe-area-inset-top, 0px); --sb: env(safe-area-inset-bottom, 0px);
  --sl: env(safe-area-inset-left, 0px); --sr: env(safe-area-inset-right, 0px);
  --rfont: 'Newsreader', serif; --rsize: 18px; --rline: 1.7;
}
[data-theme="newsprint"] {
  --bg:#DEDAD0;--surface:#E8E3D8;--text:#1A1A1A;--text2:#555548;
  --border:#C0B8A4;--accent:#5C4E35;--accent2:#453A28;
  --hl:rgba(200,170,80,0.45);
  --filter:sepia(12%) saturate(70%) brightness(92%) contrast(108%);
  --bar-bg:rgba(232,227,216,0.92);--bar-border:rgba(192,184,164,0.6);
  --shadow:rgba(26,26,26,0.1);
}
[data-theme="cream"] {
  --bg:#FFF8EC;--surface:#FFFCF5;--text:#3C3428;--text2:#8C8070;
  --border:#E8DFD0;--accent:#A08860;--accent2:#8A7450;
  --hl:rgba(230,200,120,0.35);
  --filter:sepia(8%) saturate(90%) brightness(100%) contrast(90%);
  --bar-bg:rgba(255,252,245,0.92);--bar-border:rgba(232,223,208,0.6);
  --shadow:rgba(60,52,40,0.06);
}
[data-theme="dark"] {
  --bg:#1C1B18;--surface:#262420;--text:#D4CFC4;--text2:#8A847A;
  --border:#3A3632;--accent:#C4A96A;--accent2:#D4BC82;
  --hl:rgba(196,169,106,0.3);
  --filter:brightness(85%) contrast(105%) sepia(5%);
  --bar-bg:rgba(38,36,32,0.95);--bar-border:rgba(58,54,50,0.8);
  --shadow:rgba(0,0,0,0.3);
}
body { font-family:'DM Sans',-apple-system,sans-serif; background:var(--bg); color:var(--text); }

/* ===== WELCOME ===== */
#welcome { position:fixed;inset:0;z-index:100;background:var(--bg);display:flex;flex-direction:column;transition:opacity .3s,visibility .3s; }
#welcome.hidden { opacity:0;visibility:hidden;pointer-events:none; }
.wh { padding:calc(var(--st) + 16px) 24px 12px;display:flex;align-items:center;justify-content:space-between; }
.wt { font-family:'Newsreader',serif;font-size:28px;font-weight:500;letter-spacing:-0.02em; }
.btn { display:inline-flex;align-items:center;justify-content:center;gap:6px;padding:8px 16px;border-radius:8px;border:1px solid var(--border);background:var(--surface);color:var(--text);font:500 14px 'DM Sans',sans-serif;cursor:pointer;transition:background .15s;-webkit-tap-highlight-color:transparent; }
.btn:active { background:var(--border); }
.bp { background:var(--accent);color:#fff;border-color:var(--accent); }
.bp:active { background:var(--accent2); }
.bi { padding:8px;width:40px;height:40px;border:none;background:transparent;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--text);-webkit-tap-highlight-color:transparent; }
.bi:active { background:var(--border);border-radius:8px; }
.bi svg { width:22px;height:22px; }

.lg { flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding:16px 24px calc(var(--sb) + 16px);display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:20px;align-content:start; }
.li { display:flex;flex-direction:column;gap:8px;cursor:pointer;position:relative; }
.lt { aspect-ratio:3/4;background:var(--surface);border:1px solid var(--border);border-radius:6px;overflow:hidden;box-shadow:0 2px 8px var(--shadow);transition:transform .2s; }
.lt:active { transform:scale(0.97); }
.lt canvas { width:100%;height:100%;object-fit:cover; }
.ln { font-size:13px;font-weight:500;line-height:1.3;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden; }
.lm { font-size:11px;color:var(--text2); }
.le { grid-column:1/-1;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:80px 20px;gap:16px;text-align:center; }
.le svg { width:64px;height:64px;color:var(--border); }
.le-t { font-family:'Newsreader',serif;font-size:20px;color:var(--text2); }
.le-s { font-size:14px;color:var(--text2);opacity:0.7; }
.li-del { position:absolute;top:4px;right:4px;width:28px;height:28px;border-radius:50%;background:rgba(0,0,0,0.5);border:none;display:none;align-items:center;justify-content:center;cursor:pointer;z-index:2;color:#fff; }
.li:hover .li-del, .li.show-del .li-del { display:flex; }

/* ===== READER ===== */
#reader { position:fixed;inset:0;display:none;flex-direction:column;background:var(--bg); }
#reader.on { display:flex; }

.tb { position:fixed;top:0;left:0;right:0;z-index:50;padding:calc(var(--st) + 8px) calc(var(--sr) + 12px) 8px calc(var(--sl) + 12px);background:var(--bar-bg);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);border-bottom:.5px solid var(--bar-border);display:flex;align-items:center;gap:8px;transition:transform .3s cubic-bezier(.25,.1,.25,1),opacity .3s; }
.tb.h { transform:translateY(-100%);opacity:0;pointer-events:none; }
.tb-t { flex:1;min-width:0;font-size:15px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:center; }
.tb-a { display:flex;gap:2px; }

.bb { position:fixed;bottom:0;left:0;right:0;z-index:50;padding:8px calc(var(--sr) + 16px) calc(var(--sb) + 10px) calc(var(--sl) + 16px);background:var(--bar-bg);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);border-top:.5px solid var(--bar-border);display:flex;align-items:center;gap:12px;transition:transform .3s cubic-bezier(.25,.1,.25,1),opacity .3s; }
.bb.h { transform:translateY(100%);opacity:0;pointer-events:none; }
.pl { font-size:13px;font-weight:500;color:var(--text2);min-width:60px;text-align:center;font-variant-numeric:tabular-nums; }

.ps { flex:1;-webkit-appearance:none;appearance:none;height:4px;background:var(--border);border-radius:2px;outline:none; }
.ps::-webkit-slider-thumb { -webkit-appearance:none;width:22px;height:22px;border-radius:50%;background:var(--accent);border:2px solid var(--surface);box-shadow:0 1px 4px var(--shadow);cursor:pointer; }

/* Viewport */
.vp { flex:1;overflow-y:auto;overflow-x:hidden;-webkit-overflow-scrolling:touch;padding-top:calc(var(--st) + 52px);padding-bottom:calc(var(--sb) + 60px); }
.vp.full { padding-top:0;padding-bottom:0; }
.vp.zoomed { overflow-x:auto; }
.pc { display:flex;flex-direction:column;align-items:center;gap:4px;padding:4px 0;min-height:100%;transform-origin:0 0;will-change:transform; }

/* Zoom indicator */
.zoom-badge { position:fixed;top:calc(var(--st) + 62px);right:calc(var(--sr) + 14px);z-index:55;background:var(--bar-bg);backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);border:.5px solid var(--bar-border);border-radius:8px;padding:5px 10px;font:600 12px 'DM Sans',sans-serif;color:var(--accent);opacity:0;pointer-events:none;transition:opacity .25s;box-shadow:0 2px 8px var(--shadow); }
.zoom-badge.on { opacity:1;pointer-events:auto;cursor:pointer; }
.zoom-badge.on:active { background:var(--border); }

/* Nav back button */
.nav-back { position:fixed;bottom:calc(var(--sb) + 68px);left:50%;transform:translateX(-50%);z-index:55;background:var(--accent);color:#fff;border:none;border-radius:20px;padding:8px 18px 8px 14px;font:600 13px 'DM Sans',sans-serif;display:flex;align-items:center;gap:5px;opacity:0;pointer-events:none;transition:opacity .3s;box-shadow:0 2px 12px rgba(0,0,0,.25);cursor:pointer; }
.nav-back.on { opacity:1;pointer-events:auto; }
.nav-back:active { opacity:.8; }
.nav-back svg { width:16px;height:16px; }

.pg { position:relative;width:100%;max-width:900px;display:flex;justify-content:center;flex-shrink:0; }
.pg canvas { display:block;width:100%;height:auto;filter:var(--filter); }

.tl { position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;line-height:1;pointer-events:auto; }
.tl span { position:absolute;white-space:pre;color:transparent;pointer-events:all;cursor:text; }
.tl ::selection { background:var(--hl);color:transparent; }

.ph { width:100%;aspect-ratio:var(--pr,0.773);background:var(--surface);border:1px solid var(--border);display:flex;align-items:center;justify-content:center;color:var(--text2);font-size:14px;border-radius:2px; }

/* Reflow */
.rc { display:none;flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding:calc(var(--st) + 60px) 24px calc(var(--sb) + 70px);max-width:720px;margin:0 auto;width:100%; }
.rc.on { display:block; }
.rc .rf { font-family:var(--rfont);font-size:var(--rsize);line-height:var(--rline);color:var(--text);word-wrap:break-word; }
.rf p { margin-bottom:0.8em;text-indent:1.5em; }
.rf p:first-child { text-indent:0; }

/* Search */
.sp { position:fixed;top:0;left:0;right:0;z-index:60;padding:calc(var(--st) + 8px) calc(var(--sr) + 12px) 10px calc(var(--sl) + 12px);background:var(--bar-bg);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);border-bottom:.5px solid var(--bar-border);display:none; }
.sp.on { display:block; }
.si-r { display:flex;gap:8px;align-items:center; }
.si { flex:1;padding:10px 14px;border-radius:10px;border:1px solid var(--border);background:var(--surface);color:var(--text);font:16px 'DM Sans',sans-serif;outline:none; }
.si::placeholder { color:var(--text2);opacity:0.6; }
.si:focus { border-color:var(--accent); }
.sn { display:flex;align-items:center;gap:4px; }
.sc { font-size:12px;color:var(--text2);min-width:50px;text-align:center;font-variant-numeric:tabular-nums; }
.sx { padding:8px 12px;border:none;background:none;color:var(--accent);font:500 15px 'DM Sans',sans-serif;cursor:pointer; }
.sr { max-height:200px;overflow-y:auto;margin-top:8px; }
.sr-i { padding:10px 14px;border-bottom:.5px solid var(--border);font-size:13px;color:var(--text2);cursor:pointer; }
.sr-i:active { background:var(--border); }
.sr-i .sr-p { font-weight:600;color:var(--text);margin-right:8px; }
.sr-i mark { background:var(--hl);color:var(--text);padding:1px 2px;border-radius:2px; }

/* Outline */
.oo { position:fixed;inset:0;z-index:65;background:rgba(0,0,0,0.3);opacity:0;visibility:hidden;transition:opacity .3s,visibility .3s; }
.oo.on { opacity:1;visibility:visible; }
.op { position:fixed;top:0;left:0;bottom:0;width:min(320px,80vw);z-index:70;background:var(--surface);border-right:.5px solid var(--border);display:flex;flex-direction:column;transform:translateX(-100%);transition:transform .3s cubic-bezier(.25,.1,.25,1);box-shadow:4px 0 20px var(--shadow); }
.op.on { transform:translateX(0); }
.oh { padding:calc(var(--st) + 12px) 16px 12px;border-bottom:.5px solid var(--border);display:flex;align-items:center;justify-content:space-between; }
.oh-t { font-family:'Newsreader',serif;font-size:20px;font-weight:500; }
.ol { flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;padding:8px 0; }
.oi { padding:12px 16px;font-size:14px;cursor:pointer;transition:background .15s; }
.oi:active { background:var(--border); }
.oi.i1 { padding-left:32px;font-size:13px;color:var(--text2); }
.oi.i2 { padding-left:48px;font-size:12px;color:var(--text2); }

/* Settings */
.so { position:fixed;inset:0;z-index:65;background:rgba(0,0,0,0.3);opacity:0;visibility:hidden;transition:opacity .3s,visibility .3s; }
.so.on { opacity:1;visibility:visible; }
.stp { position:fixed;bottom:0;left:0;right:0;z-index:70;background:var(--surface);border-top:.5px solid var(--border);border-radius:16px 16px 0 0;padding:20px 24px calc(var(--sb) + 20px);transform:translateY(100%);transition:transform .3s cubic-bezier(.25,.1,.25,1);box-shadow:0 -4px 20px var(--shadow);max-height:70vh;overflow-y:auto; }
.stp.on { transform:translateY(0); }
.sth { width:36px;height:4px;background:var(--border);border-radius:2px;margin:0 auto 16px; }
.ss { margin-bottom:20px; }
.ssl { font:600 12px 'DM Sans',sans-serif;text-transform:uppercase;letter-spacing:.05em;color:var(--text2);margin-bottom:10px; }

.to { display:flex;gap:10px; }
.tb2 { flex:1;padding:12px 8px;border-radius:10px;border:2px solid var(--border);background:var(--surface);font:500 12px 'DM Sans',sans-serif;color:var(--text);cursor:pointer;text-align:center;transition:border-color .15s; }
.tb2.a { border-color:var(--accent); }
.tsw { width:28px;height:28px;border-radius:50%;margin:0 auto 6px;border:1px solid rgba(0,0,0,0.1); }

.mt { display:flex;border:1px solid var(--border);border-radius:10px;overflow:hidden; }
.mb { flex:1;padding:10px;border:none;background:transparent;font:500 13px 'DM Sans',sans-serif;color:var(--text2);cursor:pointer;transition:background .15s,color .15s; }
.mb.a { background:var(--accent);color:#fff; }

.fo { display:flex;flex-direction:column;gap:6px; }
.fb { padding:10px 14px;border-radius:8px;border:1.5px solid var(--border);background:transparent;font-size:15px;color:var(--text);cursor:pointer;text-align:left;transition:border-color .15s; }
.fb.a { border-color:var(--accent);background:rgba(139,115,85,0.08); }

.szc { display:flex;align-items:center;gap:16px; }
.szb { width:40px;height:40px;border-radius:10px;border:1px solid var(--border);background:var(--surface);font:500 18px 'DM Sans',sans-serif;color:var(--text);cursor:pointer;display:flex;align-items:center;justify-content:center; }
.szb:active { background:var(--border); }
.szv { font:500 14px 'DM Sans',sans-serif;min-width:40px;text-align:center; }

/* Loading */
.lo { position:fixed;inset:0;z-index:90;background:var(--bg);display:none;flex-direction:column;align-items:center;justify-content:center;gap:16px; }
.lo.on { display:flex; }
.ls { width:32px;height:32px;border:2.5px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:sp .8s linear infinite; }
@keyframes sp { to { transform:rotate(360deg); } }
.lx { font-size:14px;color:var(--text2); }
.lb { width:200px;height:3px;background:var(--border);border-radius:2px;overflow:hidden; }
.lf { height:100%;background:var(--accent);border-radius:2px;transition:width .3s;width:0; }

/* Password */
.pd { position:fixed;inset:0;z-index:95;background:rgba(0,0,0,0.4);display:none;align-items:center;justify-content:center; }
.pd.on { display:flex; }
.pb { background:var(--surface);border-radius:14px;padding:24px;width:min(340px,85vw);box-shadow:0 8px 32px var(--shadow); }
.pb h3 { font:500 18px 'Newsreader',serif;margin-bottom:4px; }
.pb p { font-size:13px;color:var(--text2);margin-bottom:16px; }
.pb input { width:100%;padding:10px 14px;border-radius:10px;border:1px solid var(--border);background:var(--bg);color:var(--text);font:16px 'DM Sans',sans-serif;outline:none;margin-bottom:12px; }
.pb input:focus { border-color:var(--accent); }
.pa { display:flex;gap:8px;justify-content:flex-end; }

/* Context menu */
.cm { position:fixed;z-index:80;background:var(--surface);border:.5px solid var(--border);border-radius:10px;padding:4px;box-shadow:0 4px 16px var(--shadow);display:none;gap:2px; }
.cm.on { display:flex; }
.cm button { padding:8px 14px;border:none;background:none;font:500 13px 'DM Sans',sans-serif;color:var(--text);cursor:pointer;border-radius:7px;white-space:nowrap; }
.cm button:active { background:var(--border); }

/* Highlight overlays */
.hl-ov { position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;z-index:1; }
.hl-r { position:absolute;border-radius:2px;mix-blend-mode:multiply; }
[data-theme="dark"] .hl-r { mix-blend-mode:screen;opacity:.35; }
.hl-yellow { background:rgba(255,220,80,.38); }
.hl-blue { background:rgba(100,160,255,.32); }
.hl-green { background:rgba(100,210,120,.32); }
.hl-pink { background:rgba(255,140,170,.32); }

/* Color dots in context menu */
.cm-colors { display:flex;gap:3px;padding:4px 6px;border-left:.5px solid var(--border); }
.cm-colors button { width:20px;height:20px;border-radius:50%;padding:0 !important;border:2px solid transparent;flex-shrink:0;min-width:20px; }
.cm-colors button.cc-a { border-color:var(--accent); }

/* Highlights panel */
.hp { position:fixed;top:0;bottom:0;right:0;z-index:70;width:min(380px,88vw);background:var(--surface);border-left:.5px solid var(--border);transform:translateX(100%);transition:transform .3s ease;display:flex;flex-direction:column; }
.hp.on { transform:translateX(0); }
.hp-h { display:flex;align-items:center;padding:14px 16px;border-bottom:.5px solid var(--border);gap:8px; }
.hp-h h2 { flex:1;font:500 17px 'Newsreader',serif;color:var(--text); }
.hp-actions { display:flex;gap:6px; }
.hp-actions button { padding:6px 12px;border-radius:7px;font:500 12px 'DM Sans',sans-serif;color:var(--text2);border:.5px solid var(--border);white-space:nowrap; }
.hp-actions button:active { background:var(--border); }
.hp-b { flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch; }
.hl-item { display:flex;align-items:flex-start;gap:10px;padding:12px 16px;border-bottom:.5px solid var(--border);cursor:pointer; }
.hl-item:active { background:rgba(0,0,0,.04); }
.hl-dot { width:10px;height:10px;border-radius:50%;margin-top:5px;flex-shrink:0; }
.hl-body { flex:1;min-width:0; }
.hl-text { font:400 14px/1.45 'DM Sans',sans-serif;color:var(--text);display:-webkit-box;-webkit-line-clamp:3;-webkit-box-orient:vertical;overflow:hidden; }
.hl-meta { font:400 11px 'DM Sans',sans-serif;color:var(--text2);margin-top:4px; }
.hl-del { width:28px;height:28px;border-radius:6px;display:flex;align-items:center;justify-content:center;color:var(--text2);font-size:14px;flex-shrink:0;opacity:0;transition:opacity .15s; }
.hl-item:hover .hl-del { opacity:1; }
@media (hover: none) { .hl-del { opacity:1; } }
.hl-del:active { background:var(--border); }
.hl-empty { padding:40px 20px;text-align:center;color:var(--text2);font:400 14px 'DM Sans',sans-serif; }
.hp-overlay { position:fixed;inset:0;z-index:65;background:rgba(0,0,0,.25);opacity:0;pointer-events:none;transition:opacity .25s; }
.hp-overlay.on { opacity:1;pointer-events:all; }

/* Highlighter mode */
.hl-mode-bar { position:fixed;bottom:calc(var(--sb) + 60px);left:50%;transform:translateX(-50%) translateY(20px);z-index:55;background:var(--surface);border:.5px solid var(--border);border-radius:12px;padding:6px 10px;display:none;align-items:center;gap:8px;box-shadow:0 4px 20px var(--shadow);transition:transform .2s,opacity .2s; }
.hl-mode-bar.on { display:flex;transform:translateX(-50%) translateY(0); }
.hl-mode-bar .hm-label { font:500 12px 'DM Sans',sans-serif;color:var(--accent);white-space:nowrap; }
.hm-colors { display:flex;gap:4px; }
.hm-colors button { width:24px;height:24px;border-radius:50%;padding:0;border:2.5px solid transparent;flex-shrink:0;transition:border-color .15s,transform .1s; }
.hm-colors button.hm-a { border-color:var(--accent);transform:scale(1.15); }
.hm-undo { padding:5px 10px;border-radius:7px;font:500 12px 'DM Sans',sans-serif;color:var(--text2);border:.5px solid var(--border);white-space:nowrap; }
.hm-undo:active { background:var(--border); }
.hm-undo:disabled { opacity:.3; }

/* Highlighter toggle in bottom bar */
.bb-hl { width:36px;height:36px;border-radius:8px;display:flex;align-items:center;justify-content:center;color:var(--text2);border:1.5px solid var(--border);flex-shrink:0;transition:all .15s; }
.bb-hl.active { background:var(--accent);color:#fff;border-color:var(--accent); }
.bb-hl svg { width:18px;height:18px; }
.bb-undo { width:36px;height:36px;border-radius:8px;display:flex;align-items:center;justify-content:center;color:var(--text2);flex-shrink:0;transition:opacity .15s; }
.bb-undo:disabled { opacity:.25; }
.bb-undo svg { width:18px;height:18px; }

/* Live highlight preview while dragging */
.hl-preview { position:absolute;pointer-events:none;z-index:3; }
.hl-preview-rect { position:absolute;border-radius:2px;opacity:.5; }

/* When highlighter mode is on, disable native text selection on pages */
.vp.hl-active .tl { -webkit-user-select:none;user-select:none;cursor:crosshair; }
.vp.hl-active .tl span { cursor:crosshair;pointer-events:none; }

/* Annotation modal */
.ann-modal { position:fixed;inset:0;z-index:96;background:rgba(0,0,0,0.4);display:none;align-items:flex-end;justify-content:center; }
.ann-modal.on { display:flex; }
.ann-box { background:var(--surface);border-radius:16px 16px 0 0;padding:20px 20px calc(var(--sb) + 16px);width:100%;max-width:500px;box-shadow:0 -4px 20px var(--shadow);animation:ann-up .25s ease; }
@keyframes ann-up { from { transform:translateY(100%); } to { transform:translateY(0); } }
.ann-box .ann-preview { font:400 13px/1.5 'DM Sans',sans-serif;color:var(--text2);padding:10px 14px;background:var(--bg);border-radius:8px;margin-bottom:12px;max-height:60px;overflow:hidden;display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical; }
.ann-box textarea { width:100%;min-height:80px;max-height:160px;padding:12px 14px;border-radius:10px;border:1px solid var(--border);background:var(--bg);color:var(--text);font:15px 'DM Sans',sans-serif;outline:none;resize:vertical;line-height:1.5; }
.ann-box textarea:focus { border-color:var(--accent); }
.ann-box textarea::placeholder { color:var(--text2);opacity:0.5; }
.ann-actions { display:flex;gap:8px;justify-content:flex-end;margin-top:12px; }

/* Note display in highlights panel */
.hl-note { font:400 13px/1.4 'DM Sans',sans-serif;color:var(--accent2);margin-top:4px;padding:4px 8px;background:rgba(139,115,85,0.06);border-radius:4px;border-left:2px solid var(--accent);display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden; }
[data-theme="dark"] .hl-note { background:rgba(196,169,106,0.08); }
.hl-note-edit { font:400 11px 'DM Sans',sans-serif;color:var(--accent);cursor:pointer;margin-top:3px;opacity:0.7; }
.hl-note-edit:active { opacity:1; }

/* Bookmarks panel */
.bm-panel { position:fixed;top:0;bottom:0;right:0;z-index:70;width:min(380px,88vw);background:var(--surface);border-left:.5px solid var(--border);transform:translateX(100%);transition:transform .3s ease;display:flex;flex-direction:column; }
.bm-panel.on { transform:translateX(0); }
.bm-panel-h { display:flex;align-items:center;padding:14px 16px;border-bottom:.5px solid var(--border);gap:8px; }
.bm-panel-h h2 { flex:1;font:500 17px 'Newsreader',serif;color:var(--text); }
.bm-list { flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch; }
.bm-item { display:flex;align-items:center;gap:10px;padding:12px 16px;border-bottom:.5px solid var(--border);cursor:pointer; }
.bm-item:active { background:rgba(0,0,0,.04); }
.bm-icon { width:28px;height:28px;display:flex;align-items:center;justify-content:center;color:var(--accent);flex-shrink:0; }
.bm-body { flex:1;min-width:0; }
.bm-name { font:500 14px/1.4 'DM Sans',sans-serif;color:var(--text); }
.bm-meta { font:400 11px 'DM Sans',sans-serif;color:var(--text2);margin-top:2px; }
.bm-del { width:28px;height:28px;border-radius:6px;display:flex;align-items:center;justify-content:center;color:var(--text2);font-size:14px;flex-shrink:0;opacity:0;transition:opacity .15s; }
.bm-item:hover .bm-del { opacity:1; }
@media (hover: none) { .bm-del { opacity:1; } }
.bm-del:active { background:var(--border); }
.bm-empty { padding:40px 20px;text-align:center;color:var(--text2);font:400 14px 'DM Sans',sans-serif; }
.bm-overlay { position:fixed;inset:0;z-index:65;background:rgba(0,0,0,.25);opacity:0;pointer-events:none;transition:opacity .25s; }
.bm-overlay.on { opacity:1;pointer-events:all; }

/* Rename dialog */
.rn-modal { position:fixed;inset:0;z-index:96;background:rgba(0,0,0,0.4);display:none;align-items:center;justify-content:center; }
.rn-modal.on { display:flex; }
.rn-box { background:var(--surface);border-radius:14px;padding:24px;width:min(340px,85vw);box-shadow:0 8px 32px var(--shadow); }
.rn-box h3 { font:500 18px 'Newsreader',serif;margin-bottom:12px; }
.rn-box input { width:100%;padding:10px 14px;border-radius:10px;border:1px solid var(--border);background:var(--bg);color:var(--text);font:16px 'DM Sans',sans-serif;outline:none;margin-bottom:12px; }
.rn-box input:focus { border-color:var(--accent); }
.rn-actions { display:flex;gap:8px;justify-content:flex-end; }

/* Storage bar */
.storage-bar { grid-column:1/-1;padding:12px 16px;display:flex;align-items:center;gap:10px; }
.storage-track { flex:1;height:6px;background:var(--border);border-radius:3px;overflow:hidden; }
.storage-fill { height:100%;background:var(--accent);border-radius:3px;transition:width .3s; }
.storage-fill.warn { background:#c44; }
.storage-label { font:400 12px 'DM Sans',sans-serif;color:var(--text2);white-space:nowrap; }

/* Delete dialog */
.dd { position:fixed;inset:0;z-index:95;background:rgba(0,0,0,0.4);display:none;align-items:center;justify-content:center; }
.dd.on { display:flex; }
.db { background:var(--surface);border-radius:14px;padding:24px;width:min(300px,80vw);text-align:center; }
.db h3 { font:500 18px 'Newsreader',serif;margin-bottom:8px; }
.db p { font-size:13px;color:var(--text2);margin-bottom:16px; }
.db .da { display:flex;gap:8px;justify-content:center; }
.bd { background:#c44;color:#fff;border-color:#c44; }

@media(max-width:500px) {
  .lg { grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:14px;padding:12px 16px; }
  .wh { padding-left:16px;padding-right:16px; }
}
</style>
</head>
<body data-theme="sepia">

<!-- WELCOME -->
<div id="welcome">
<div class="wh">
  <div class="wt">The Reader</div>
  <button class="btn bp" id="open-btn">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M5 12h14"/></svg>
    Open PDF
  </button>
</div>
<div class="lg" id="lib"></div>
<div style="text-align:center;padding:16px 0 24px">
  <button id="welcome-reset" style="font:400 13px 'DM Sans',sans-serif;color:var(--text2);text-decoration:underline;background:none;border:none;cursor:pointer">Reset Cache &amp; Data</button>
</div>
</div>

<!-- READER -->
<div id="reader">
<div class="tb" id="tb">
  <button class="bi" id="btn-back" aria-label="Back"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></button>
  <div class="tb-t" id="tb-t"></div>
  <div class="tb-a">
    <button class="bi" id="btn-search" aria-label="Search"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><path d="M21 21l-4.35-4.35"/></svg></button>
    <button class="bi" id="btn-outline" aria-label="Contents"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="15" y2="12"/><line x1="3" y1="18" x2="11" y2="18"/></svg></button>
    <button class="bi" id="btn-hl" aria-label="Highlights"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.12 2.12 0 013 3L7 19l-4 1 1-4z"/></svg></button>
    <button class="bi" id="btn-bm" aria-label="Bookmarks"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/></svg></button>
    <button class="bi" id="btn-settings" aria-label="Settings"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="1"/><circle cx="12" cy="5" r="1"/><circle cx="12" cy="19" r="1"/></svg></button>
  </div>
</div>

<div class="vp" id="vp">
  <div class="pc" id="pc"></div>
</div>
<div class="zoom-badge" id="zoom-badge">1.0x</div>
<button class="nav-back" id="nav-back"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>Back</button>
<div class="rc" id="rc"><div class="rf" id="rf"></div></div>

<div class="bb" id="bb">
  <button class="bb-undo" id="btn-undo" disabled aria-label="Undo"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 105.17-9.34L1 10"/></svg></button>
  <span class="pl" id="pl">1 / 1</span>
  <input type="range" class="ps" id="ps" min="1" max="1" value="1">
  <button class="bb-hl" id="btn-hlmode" aria-label="Highlighter"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"/><path d="M16.5 3.5a2.12 2.12 0 013 3L7 19l-4 1 1-4z"/></svg></button>
</div>

<!-- Floating highlighter bar -->
<div class="hl-mode-bar" id="hlbar">
  <span class="hm-label">Highlighter</span>
  <div class="hm-colors">
    <button data-hmc="yellow" class="hm-a" style="background:rgba(255,220,80,.7)"></button>
    <button data-hmc="blue" style="background:rgba(100,160,255,.6)"></button>
    <button data-hmc="green" style="background:rgba(100,210,120,.6)"></button>
    <button data-hmc="pink" style="background:rgba(255,140,170,.6)"></button>
  </div>
  <button class="hm-undo" id="btn-undo2" disabled>Undo</button>
</div>
</div>

<!-- SEARCH -->
<div class="sp" id="sp">
<div class="si-r">
  <input type="text" class="si" id="si" placeholder="Search in document..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  <div class="sn">
    <span class="sc" id="sc"></span>
    <button class="bi" id="btn-sprev" style="width:32px;height:32px"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M18 15l-6-6-6 6"/></svg></button>
    <button class="bi" id="btn-snext" style="width:32px;height:32px"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9l6 6 6-6"/></svg></button>
  </div>
  <button class="sx" id="btn-sdone">Done</button>
</div>
<div class="sr" id="sr"></div>
</div>

<!-- OUTLINE -->
<div class="oo" id="oo"></div>
<div class="op" id="op">
<div class="oh"><span class="oh-t">Contents</span><button class="bi" id="btn-oclose"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18M6 6l12 12"/></svg></button></div>
<div class="ol" id="ol"></div>
</div>

<!-- SETTINGS -->
<div class="so" id="so"></div>
<div class="stp" id="stp">
<div class="sth"></div>
<div class="ss"><div class="ssl">View Mode</div>
<div class="mt"><button class="mb a" data-m="scroll">Scroll</button><button class="mb" data-m="reflow">Reflow</button></div></div>

<div class="ss"><div class="ssl">Theme</div>
<div class="to">
<button class="tb2 a" data-tv="sepia"><div class="tsw" style="background:#F0E6D3"></div>Sepia</button>
<button class="tb2" data-tv="newsprint"><div class="tsw" style="background:#DEDAD0"></div>Newsprint</button>
<button class="tb2" data-tv="cream"><div class="tsw" style="background:#FFF8EC"></div>Cream</button>
<button class="tb2" data-tv="dark"><div class="tsw" style="background:#1C1B18;border-color:rgba(255,255,255,0.15)"></div>Dark</button>
</div></div>

<div class="ss" id="s-font" style="display:none"><div class="ssl">Font</div>
<div class="fo">
<button class="fb a" data-f="'Newsreader', serif" style="font-family:'Newsreader',serif">Newsreader</button>
<button class="fb" data-f="'Literata', serif" style="font-family:'Literata',serif">Literata</button>
<button class="fb" data-f="'EB Garamond', serif" style="font-family:'EB Garamond',serif">EB Garamond</button>
<button class="fb" data-f="'Source Serif 4', serif" style="font-family:'Source Serif 4',serif">Source Serif 4</button>
<button class="fb" data-f="'Crimson Pro', serif" style="font-family:'Crimson Pro',serif">Crimson Pro</button>
</div></div>

<div class="ss" id="s-size" style="display:none"><div class="ssl">Text Size</div>
<div class="szc"><button class="szb" id="sz-down">−</button><span class="szv" id="szv">18px</span><button class="szb" id="sz-up">+</button></div></div>

<div class="ss"><div class="ssl">Data</div>
<button class="btn" id="btn-reset" style="width:100%;margin-top:4px;color:#c44;border-color:#c44">Reset Cache &amp; Data</button>
</div>
</div>

<!-- LOADING -->
<div class="lo" id="lo"><div class="ls"></div><div class="lx" id="lx">Loading...</div><div class="lb"><div class="lf" id="lf"></div></div></div>

<!-- PASSWORD -->
<div class="pd" id="pd"><div class="pb"><h3>Password Required</h3><p>This PDF is password-protected.</p><input type="password" id="pw" placeholder="Enter password" autocomplete="off"><div class="pa"><button class="btn" id="pw-cancel">Cancel</button><button class="btn bp" id="pw-ok">Open</button></div></div></div>

<!-- DELETE -->
<div class="dd" id="dd"><div class="db"><h3>Remove from Library?</h3><p id="dd-n"></p><div class="da"><button class="btn" id="dd-cancel">Cancel</button><button class="btn bd" id="dd-ok">Remove</button></div></div></div>

<!-- CONTEXT MENU -->
<div class="cm" id="cm"><button id="cm-copy">Copy</button><div class="cm-colors"><button data-hc="yellow" class="cc-a" style="background:rgba(255,220,80,.6)"></button><button data-hc="blue" style="background:rgba(100,160,255,.5)"></button><button data-hc="green" style="background:rgba(100,210,120,.5)"></button><button data-hc="pink" style="background:rgba(255,140,170,.5)"></button></div><button id="cm-hl">Highlight</button><button id="cm-def">Define</button></div>

<!-- ANNOTATION MODAL -->
<div class="ann-modal" id="ann-modal">
<div class="ann-box">
  <div class="ann-preview" id="ann-preview"></div>
  <textarea id="ann-input" placeholder="Add a note..." rows="3"></textarea>
  <div class="ann-actions">
    <button class="btn" id="ann-skip">Skip</button>
    <button class="btn bp" id="ann-save">Save Note</button>
  </div>
</div>
</div>

<!-- HIGHLIGHTS PANEL -->
<div class="hp-overlay" id="hp-ov"></div>
<div class="hp" id="hp">
  <div class="hp-h">
    <h2>Highlights</h2>
    <div class="hp-actions">
      <button id="hl-export-json" title="Export as JSON">Export</button>
      <button id="hl-import-json" title="Import from JSON">Import</button>
      <button id="hl-copy-md" title="Copy as Markdown">Copy All</button>
      <button id="hl-copy-notion" title="Copy formatted for Notion">Notion</button>
      <button id="hl-share" title="Share highlights">Share</button>
    </div>
    <button class="bi" id="btn-hclose"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18M6 6l12 12"/></svg></button>
  </div>
  <div class="hp-b" id="hl-list"></div>
</div>

<!-- BOOKMARKS PANEL -->
<div class="bm-overlay" id="bm-ov"></div>
<div class="bm-panel" id="bm-panel">
  <div class="bm-panel-h">
    <h2>Bookmarks</h2>
    <button class="bi" id="btn-bm-add" title="Bookmark this page"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/></svg></button>
    <button class="bi" id="btn-bmclose"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18M6 6l12 12"/></svg></button>
  </div>
  <div class="bm-list" id="bm-list"></div>
</div>

<!-- RENAME MODAL -->
<div class="rn-modal" id="rn-modal">
<div class="rn-box">
  <h3>Rename Bookmark</h3>
  <input type="text" id="rn-input" placeholder="Bookmark name" autocomplete="off">
  <div class="rn-actions">
    <button class="btn" id="rn-cancel">Cancel</button>
    <button class="btn bp" id="rn-save">Save</button>
  </div>
</div>
</div>

<input type="file" id="hl-import-fi" accept=".json,application/json" style="display:none">
<input type="file" id="fi" accept=".pdf,application/pdf" style="display:none">


<script type="module">
// ================================================
// INIT PDF.JS (4.9.155 from CDN, ES module)
// ================================================
const pdfjsLib = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.9.155/pdf.min.mjs');
window.pdfjsLib = pdfjsLib; // global ref for compatibility
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.9.155/pdf.worker.min.mjs';

// PDF.js document config
const PDF_CONF = {
  cMapUrl: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.9.155/cmaps/',
  cMapPacked: true
};

// ================================================
// STATE
// ================================================
let PDF = null, DOC_ID = null, TOTAL = 0, CUR = 1;
let RATIO = 0.773, MODE = 'scroll', CHROME = true;
let RSIZE = 18;
const BUFFER = 2;
const rendered = new Map(), slots = new Map(), txtCache = new Map();
let obs = null, sResults = [], sIdx = -1, sAbort = null;
let outline = [];
let db = null;
let pendData = null, pendName = null, delId = null;
let highlights = [], savedSel = null, hlColor = 'yellow';
let hlModeActive = false, hlUndoStack = [];
let pendingAnnotationId = null; // highlight ID awaiting a note
let bookmarks = [];
let zoomLevel = 1, zoomMin = 1, zoomMax = 4;
let lastTapTime = 0, lastTapX = 0, lastTapY = 0; // double-tap detection
let pinchStartDist = 0, pinchStartZoom = 1;

// ================================================
// INDEXED DB
// ================================================
function openDB() {
  return new Promise((ok, no) => {
    const r = indexedDB.open('TheReaderV3', 3);
    r.onupgradeneeded = e => {
      const d = e.target.result;
      if (!d.objectStoreNames.contains('docs')) d.createObjectStore('docs', { keyPath: 'id' });
      if (!d.objectStoreNames.contains('cfg')) d.createObjectStore('cfg', { keyPath: 'k' });
      if (!d.objectStoreNames.contains('highlights')) {
        const hs = d.createObjectStore('highlights', { keyPath: 'id' });
        hs.createIndex('docId', 'docId', { unique: false });
      }
      if (!d.objectStoreNames.contains('bookmarks')) {
        const bs = d.createObjectStore('bookmarks', { keyPath: 'id' });
        bs.createIndex('docId', 'docId', { unique: false });
      }
    };
    r.onsuccess = () => { db = r.result; ok(db); };
    r.onerror = () => {
      console.warn('DB open failed, deleting and retrying...');
      indexedDB.deleteDatabase('TheReaderV3');
      const r2 = indexedDB.open('TheReaderV3', 2);
      r2.onupgradeneeded = e => {
        const d = e.target.result;
        d.createObjectStore('docs', { keyPath: 'id' });
        d.createObjectStore('cfg', { keyPath: 'k' });
        const hs = d.createObjectStore('highlights', { keyPath: 'id' });
        hs.createIndex('docId', 'docId', { unique: false });
        const bs = d.createObjectStore('bookmarks', { keyPath: 'id' });
        bs.createIndex('docId', 'docId', { unique: false });
      };
      r2.onsuccess = () => { db = r2.result; ok(db); };
      r2.onerror = () => no(r2.error);
    };
    r.onblocked = () => {
      console.warn('DB upgrade blocked — close other tabs');
      // Force close and retry
      setTimeout(() => {
        const r3 = indexedDB.open('TheReaderV3', 3);
        r3.onsuccess = () => { db = r3.result; ok(db); };
        r3.onerror = () => no(r3.error);
      }, 1000);
    };
  });
}

async function resetAllData() {
  if (!confirm('This will delete all saved PDFs, highlights, and settings. Continue?')) return;
  try {
    if (db) db.close();
    await new Promise((ok, no) => {
      const r = indexedDB.deleteDatabase('TheReaderV3');
      r.onsuccess = ok; r.onerror = no;
    });
    localStorage.clear();
    location.reload();
  } catch(e) {
    alert('Reset failed: ' + e.message);
    location.reload();
  }
}
const dbPut = (s, v) => new Promise((ok, no) => { const t = db.transaction(s, 'readwrite'); t.objectStore(s).put(v); t.oncomplete = ok; t.onerror = no; });
const dbGet = (s, k) => new Promise(ok => { const t = db.transaction(s, 'readonly'); const r = t.objectStore(s).get(k); r.onsuccess = () => ok(r.result); r.onerror = () => ok(null); });
const dbAll = (s) => new Promise(ok => { const t = db.transaction(s, 'readonly'); const r = t.objectStore(s).getAll(); r.onsuccess = () => ok(r.result || []); r.onerror = () => ok([]); });
const dbDel = (s, k) => new Promise((ok, no) => { const t = db.transaction(s, 'readwrite'); t.objectStore(s).delete(k); t.oncomplete = ok; t.onerror = no; });
const dbIdx = (s, i, k) => new Promise(ok => { const t = db.transaction(s, 'readonly'); const r = t.objectStore(s).index(i).getAll(k); r.onsuccess = () => ok(r.result || []); r.onerror = () => ok([]); });
const setCfg = (k, v) => dbPut('cfg', { k, v });
const getCfg = async k => { const r = await dbGet('cfg', k); return r?.v; };

// ================================================
// DOM REFS
// ================================================
const $ = id => document.getElementById(id);
const welcome = $('welcome'), reader = $('reader');
const tb = $('tb'), bb = $('bb'), vp = $('vp'), pc = $('pc');
const rc = $('rc'), rf = $('rf');
const tbT = $('tb-t'), pl = $('pl'), ps = $('ps');
const sp = $('sp'), si = $('si'), sc = $('sc'), sr = $('sr');
const op = $('op'), oo = $('oo'), ol = $('ol');
const stp = $('stp'), so = $('so');
const lo = $('lo'), lx = $('lx'), lf = $('lf');
const pd = $('pd'), pw = $('pw');
const dd = $('dd'), ddN = $('dd-n');
const cm = $('cm');
const hp = $('hp'), hlList = $('hl-list'), hpOv = $('hp-ov');
const fi = $('fi');
const annModal = $('ann-modal'), annPreview = $('ann-preview'), annInput = $('ann-input');
const bmPanel = $('bm-panel'), bmList = $('bm-list'), bmOv = $('bm-ov');
const rnModal = $('rn-modal'), rnInput = $('rn-input');
const hlImportFi = $('hl-import-fi');
const zoomBadge = $('zoom-badge');
const navBackBtn = $('nav-back');

// ================================================
// EVENTS
// ================================================
$('open-btn').onclick = () => fi.click();
fi.onchange = async e => {
  const f = e.target.files?.[0]; if (!f) return;
  fi.value = '';
  showLoad('Reading file...');
  try {
    const buf = await f.arrayBuffer();
    await loadPDF(new Uint8Array(buf), f.name);
  } catch(e) { hideLoad(); alert('Could not read file: ' + e.message); }
};

$('btn-back').onclick = closeReader;
$('btn-search').onclick = toggleSearch;
$('btn-outline').onclick = toggleOutline;
$('btn-settings').onclick = toggleSettings;
$('btn-reset').onclick = resetAllData;
$('welcome-reset').onclick = resetAllData;
$('btn-hl').onclick = toggleHighlights;
$('btn-hclose').onclick = closeHighlights;
hpOv.onclick = closeHighlights;
$('hl-copy-md').onclick = () => {
  const md = highlightsToMarkdown();
  if (!md) { showToast('No highlights'); return; }
  navigator.clipboard.writeText(md).then(() => showToast('Copied as Markdown')).catch(() => showToast('Copy failed'));
};
$('hl-copy-notion').onclick = () => {
  const txt = highlightsToNotion();
  if (!txt) { showToast('No highlights'); return; }
  navigator.clipboard.writeText(txt).then(() => showToast('Copied for Notion')).catch(() => showToast('Copy failed'));
};
$('hl-share').onclick = async () => {
  const txt = highlightsToNotion();
  if (!txt) { showToast('No highlights'); return; }
  if (navigator.share) {
    try {
      await navigator.share({ title: document.querySelector('.tb-t')?.textContent + ' — Highlights', text: txt });
    } catch(e) { if (e.name !== 'AbortError') showToast('Share failed'); }
  } else {
    navigator.clipboard.writeText(txt).then(() => showToast('Copied to clipboard')).catch(() => showToast('Copy failed'));
  }
};
// Highlight JSON export/import
$('hl-export-json').onclick = () => {
  if (!highlights.length) { showToast('No highlights to export'); return; }
  const docName = document.querySelector('.tb-t')?.textContent || 'Document';
  const data = {
    docName, docId: DOC_ID,
    exportedAt: new Date().toISOString(),
    highlights: highlights.map(h => ({
      page: h.page, text: h.text, rects: h.rects, color: h.color,
      note: h.note || '', createdAt: h.createdAt
    }))
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = docName.replace(/[^a-zA-Z0-9]/g, '_') + '_highlights.json';
  a.click(); URL.revokeObjectURL(url);
  showToast('Exported ' + highlights.length + ' highlights');
};
$('hl-import-json').onclick = () => hlImportFi.click();
hlImportFi.onchange = async e => {
  const f = e.target.files?.[0]; if (!f) return;
  hlImportFi.value = '';
  try {
    const text = await f.text();
    const data = JSON.parse(text);
    if (!data.highlights?.length) { showToast('No highlights found in file'); return; }
    if (!DOC_ID || !db) { showToast('Open a document first'); return; }
    let imported = 0;
    for (const h of data.highlights) {
      const hl = {
        id: 'hl_' + Date.now() + '_' + Math.random().toString(36).slice(2,6) + '_' + imported,
        docId: DOC_ID, page: h.page, text: (h.text || '').substring(0, 500),
        rects: h.rects || [], color: h.color || 'yellow',
        note: h.note || '', createdAt: h.createdAt || Date.now()
      };
      await dbPut('highlights', hl);
      highlights.push(hl);
      imported++;
    }
    // Refresh overlays on all rendered pages
    for (const [n] of rendered) { if (rendered.get(n) !== 'wip') refreshHighlightsOnPage(n); }
    renderHighlightsPanel();
    showToast('Imported ' + imported + ' highlights');
  } catch(err) { showToast('Import failed: invalid JSON'); }
};
// Bookmarks
$('btn-bm').onclick = toggleBookmarks;
$('btn-bmclose').onclick = closeBookmarks;
$('bm-ov').onclick = closeBookmarks;
$('btn-bm-add').onclick = addBookmark;

// Rename bookmark modal
let renameBookmarkId = null;
$('rn-cancel').onclick = () => { rnModal.classList.remove('on'); renameBookmarkId = null; };
$('rn-save').onclick = async () => {
  if (renameBookmarkId && rnInput.value.trim()) {
    const bm = bookmarks.find(b => b.id === renameBookmarkId);
    if (bm) { bm.name = rnInput.value.trim(); await dbPut('bookmarks', bm); renderBookmarksPanel(); }
  }
  rnModal.classList.remove('on'); renameBookmarkId = null;
};
rnInput.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); $('rn-save').click(); } });

$('btn-sdone').onclick = toggleSearch;
$('btn-sprev').onclick = sPrev;
$('btn-snext').onclick = sNext;
oo.onclick = toggleOutline;
$('btn-oclose').onclick = toggleOutline;
so.onclick = toggleSettings;

// Password
$('pw-ok').onclick = async () => {
  const p = pw.value; if (!p) return;
  pd.classList.remove('on');
  if (pendData && pendName) await loadPDF(pendData, pendName, p);
  pendData = pendName = null;
};
$('pw-cancel').onclick = () => { pd.classList.remove('on'); pendData = pendName = null; };
pw.onkeydown = e => { if (e.key === 'Enter') $('pw-ok').click(); };

// Delete
$('dd-cancel').onclick = () => { dd.classList.remove('on'); delId = null; };
$('dd-ok').onclick = async () => {
  if (delId) await dbDel('docs', delId);
  dd.classList.remove('on'); delId = null;
  renderLib();
};

// Annotation modal
$('ann-skip').onclick = () => { annModal.classList.remove('on'); annInput.value = ''; pendingAnnotationId = null; };
$('ann-save').onclick = async () => {
  if (pendingAnnotationId && annInput.value.trim()) {
    await updateHighlightNote(pendingAnnotationId, annInput.value.trim());
    if (hp.classList.contains('on')) renderHighlightsPanel();
  }
  annModal.classList.remove('on'); annInput.value = ''; pendingAnnotationId = null;
};
annInput.addEventListener('keydown', e => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); $('ann-save').click(); } });

// Scrubber
ps.oninput = e => updatePL(parseInt(e.target.value));
ps.onchange = e => {
  const p = parseInt(e.target.value);
  if (zoomLevel > 1) resetZoom();
  if (MODE === 'scroll') scrollTo(p, false);
  else { const el = $('rp-' + p); if (el) el.scrollIntoView({ behavior: 'auto' }); CUR = p; updatePL(p); }
};

// Mode buttons
document.querySelectorAll('.mb').forEach(b => b.onclick = () => setMode(b.dataset.m));

// Theme buttons
document.querySelectorAll('.tb2').forEach(b => b.onclick = () => setTheme(b.dataset.tv));

// Font buttons
document.querySelectorAll('.fb').forEach(b => b.onclick = () => {
  document.documentElement.style.setProperty('--rfont', b.dataset.f);
  document.querySelectorAll('.fb').forEach(x => x.classList.toggle('a', x === b));
  applyReflow(); setCfg('font', b.dataset.f);
});

// Size
$('sz-down').onclick = () => adjSize(-1);
$('sz-up').onclick = () => adjSize(1);

// Context menu - prevent selection loss on button tap
cm.addEventListener('pointerdown', e => { e.preventDefault(); e.stopPropagation(); });
cm.addEventListener('touchstart', e => { e.stopPropagation(); }, { passive: true });

// Color picker
document.querySelectorAll('[data-hc]').forEach(b => {
  b.onclick = e => {
    e.stopPropagation();
    document.querySelectorAll('[data-hc]').forEach(x => x.classList.remove('cc-a'));
    b.classList.add('cc-a');
    hlColor = b.dataset.hc;
  };
});

$('cm-copy').onclick = () => {
  const s = savedSel?.text || window.getSelection()?.toString();
  if (s) navigator.clipboard.writeText(s).catch(() => {});
  window.getSelection()?.removeAllRanges();
  hideCM(); savedSel = null;
};
$('cm-hl').onclick = doHighlightAction;
// Backup: touchend fires before selection clears on some iOS versions
let hlActionDone = false;
$('cm-hl').addEventListener('touchend', e => { e.preventDefault(); if (!hlActionDone) doHighlightAction(); }, { passive: false });

function doHighlightAction() {
  hlActionDone = true;
  setTimeout(() => { hlActionDone = false; }, 300);
  if (!savedSel || !savedSel.rects.length) {
    if (savedSel && savedSel.text) showToast('Could not locate text position');
    hideCM(); return;
  }
  saveHighlight(savedSel.page, savedSel.text, savedSel.rects, hlColor);
  window.getSelection()?.removeAllRanges();
  hideCM(); savedSel = null;
}

$('cm-def').onclick = () => {
  const s = savedSel?.text || window.getSelection()?.toString()?.trim();
  if (s) window.open('https://www.google.com/search?q=define+' + encodeURIComponent(s), '_blank');
  window.getSelection()?.removeAllRanges(); hideCM(); savedSel = null;
};

// Delayed hide to prevent click-swallowing race condition
let cmHideTimer = null;
function hideCM() { cm.classList.remove('on'); }
function scheduleCMHide() {
  clearTimeout(cmHideTimer);
  cmHideTimer = setTimeout(hideCM, 150);
}
function cancelCMHide() { clearTimeout(cmHideTimer); }

// Keep menu alive while interacting with it
cm.addEventListener('pointerenter', cancelCMHide);
cm.addEventListener('pointerleave', () => {
  if (!window.getSelection()?.toString().trim()) scheduleCMHide();
});

// Selection detection — capture data BEFORE any button tap clears it
document.addEventListener('selectionchange', () => {
  const sel = window.getSelection();
  if (sel && sel.toString().trim()) {
    cancelCMHide();
    try {
      const range = sel.getRangeAt(0);
      const text = sel.toString().trim();

      // Find the page slot this selection is in
      let node = range.commonAncestorContainer;
      if (node.nodeType === 3) node = node.parentElement;
      const slot = node?.closest?.('[data-p]');
      const canvas = slot?.querySelector('canvas');

      if (slot && canvas) {
        const pn = +slot.dataset.p;
        const cr = canvas.getBoundingClientRect();
        const clientRects = range.getClientRects();
        const rects = [];
        for (const r of clientRects) {
          rects.push({
            x: (r.left - cr.left) / cr.width,
            y: (r.top - cr.top) / cr.height,
            w: r.width / cr.width,
            h: r.height / cr.height
          });
        }
        savedSel = { text, page: pn, rects };
      } else {
        savedSel = { text, page: 0, rects: [] };
      }

      // Position popup
      const r = range.getBoundingClientRect();
      let top = r.top - 44, left = r.left + r.width/2 - 100;
      if (top < 60) top = r.bottom + 8;
      if (left < 8) left = 8;
      if (left + 200 > window.innerWidth) left = window.innerWidth - 208;
      cm.style.top = top + 'px'; cm.style.left = left + 'px';
      cm.classList.add('on');
    } catch(e) {}
  } else {
    // Don't immediately hide — give click handlers time to fire
    scheduleCMHide();
  }
});

// Search input
let sTimer = null;
si.oninput = e => {
  clearTimeout(sTimer);
  const q = e.target.value.trim();
  if (q.length < 2) { sResults = []; sIdx = -1; sc.textContent = ''; sr.innerHTML = ''; return; }
  sTimer = setTimeout(() => doSearch(q), 300);
};

// ================================================
// LOAD PDF
// ================================================
async function loadPDF(data, name, password, startPage) {
  showLoad('Opening PDF...');
  try {
    const params = { data: data.slice(0), ...PDF_CONF };
    if (password) params.password = password;

    const task = pdfjsLib.getDocument(params);
    task.onProgress = p => { if (p.total > 0) setLP(Math.round(p.loaded/p.total*50)); };

    PDF = await task.promise;
    TOTAL = PDF.numPages;

    const p1 = await PDF.getPage(1);
    const v = p1.getViewport({ scale: 1 });
    RATIO = v.width / v.height;
    document.documentElement.style.setProperty('--pr', RATIO);

    const id = name.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 40) + '_' + Date.now().toString(36);
    DOC_ID = id;
    await dbPut('docs', { id, name, data: new Uint8Array(data), lastPage: startPage || 1, lastOpened: Date.now() });

    try { outline = (await PDF.getOutline()) || []; buildOutline(outline); } catch(e) { outline = []; }

    await setupReader(name, startPage || 1);
    setLP(100); setTimeout(hideLoad, 200);
  } catch(e) {
    hideLoad();
    if (e.name === 'PasswordException') { pendData = data; pendName = name; pd.classList.add('on'); pw.value = ''; pw.focus(); }
    else alert('Could not open PDF: ' + e.message);
  }
}

// ================================================
// READER SETUP
// ================================================
async function setupReader(name, start) {
  welcome.classList.add('hidden');
  reader.classList.add('on');
  tbT.textContent = name.replace(/\.pdf$/i, '');
  ps.max = TOTAL; ps.value = start;
  rendered.clear(); slots.clear(); txtCache.clear(); sResults = [];
  // Load highlights and bookmarks for this document
  await loadHighlights();
  await loadBookmarks();
  if (MODE === 'scroll') setupScroll(start);
  else setupReflow(start);
  updatePL(start); CHROME = true;
}

// ================================================
// SCROLL MODE
// ================================================
function setupScroll(start) {
  vp.style.display = ''; rc.classList.remove('on');
  pc.innerHTML = '';

  for (let i = 1; i <= TOTAL; i++) {
    const s = document.createElement('div');
    s.className = 'pg'; s.dataset.p = i;
    const ph = document.createElement('div');
    ph.className = 'ph'; ph.textContent = i;
    s.appendChild(ph);
    pc.appendChild(s);
    slots.set(i, s);
  }

  if (obs) obs.disconnect();
  obs = new IntersectionObserver(entries => {
    for (const e of entries) {
      if (!e.isIntersecting) continue;
      const n = parseInt(e.target.dataset.p);
      renderPage(n);
      for (let b = 1; b <= BUFFER; b++) {
        if (n+b <= TOTAL) renderPage(n+b);
        if (n-b >= 1) renderPage(n-b);
      }
    }
  }, { root: vp, rootMargin: '200% 0px', threshold: 0 });

  slots.forEach(s => obs.observe(s));

  let tick = false;
  vp.onscroll = () => { if (!tick) { tick = true; requestAnimationFrame(() => { updateCurFromScroll(); tick = false; }); } };
  vp.onclick = tapToggle;

  if (start > 1) requestAnimationFrame(() => scrollTo(start, false));
  cleanInterval = setInterval(cleanup, 3000);
}

let cleanInterval = null;

async function renderPage(n) {
  if (rendered.has(n)) return;
  rendered.set(n, 'wip');
  try {
    const page = await PDF.getPage(n);
    const slot = slots.get(n); if (!slot) { rendered.delete(n); return; }
    const cw = slot.clientWidth || 900;
    // Cap DPR to reduce canvas memory — iOS Safari limits total canvas memory
    // On iPad (dpr 2), large pages can exhaust GPU memory causing blank renders
    const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
    const baseVP = page.getViewport({ scale: 1 });
    const scale = (cw * dpr) / baseVP.width;
    const viewport = page.getViewport({ scale });

    // Safety: cap canvas dimensions (iOS fails silently above ~16M pixels)
    const maxDim = 4096;
    let finalScale = scale;
    if (viewport.width > maxDim || viewport.height > maxDim) {
      const shrink = maxDim / Math.max(viewport.width, viewport.height);
      finalScale = scale * shrink;
    }
    const finalVP = finalScale !== scale ? page.getViewport({ scale: finalScale }) : viewport;

    const canvas = document.createElement('canvas');
    canvas.width = finalVP.width; canvas.height = finalVP.height;
    canvas.style.width = '100%'; canvas.style.height = 'auto';

    const ctx = canvas.getContext('2d');
    if (!ctx) {
      console.warn('Canvas context null for page', n, '— forcing cleanup');
      cleanup(true); // aggressive cleanup
      rendered.delete(n);
      // Retry once after cleanup
      setTimeout(() => { rendered.delete(n); renderPage(n); }, 100);
      return;
    }

    await page.render({ canvasContext: ctx, viewport: finalVP }).promise;

    // Text layer
    const tc = await page.getTextContent();
    const tl = document.createElement('div');
    tl.className = 'tl';
    const ds = cw / baseVP.width;
    tc.items.forEach(item => {
      const tx = item.transform;
      const sp = document.createElement('span');
      sp.textContent = item.str;
      const fs = Math.sqrt(tx[0]*tx[0] + tx[1]*tx[1]);
      sp.style.fontSize = (fs * ds) + 'px';
      sp.style.left = (tx[4] * ds) + 'px';
      sp.style.top = ((baseVP.height - tx[5]) * ds - fs * ds) + 'px';
      tl.appendChild(sp);
    });
    txtCache.set(n, tc.items.map(i => i.str).join(' '));

    slot.innerHTML = '';
    slot.appendChild(canvas);
    // Highlight overlay
    const hlOv = buildHighlightOverlay(n, canvas);
    if (hlOv) slot.appendChild(hlOv);
    slot.appendChild(tl);
    rendered.set(n, true);
  } catch(e) {
    console.warn('Render err page', n, e?.message || e);
    rendered.delete(n);
  }
}

function cleanup(aggressive) {
  if (MODE !== 'scroll') return;
  const keep = aggressive ? BUFFER + 1 : BUFFER * 2 + 3;
  for (const [n] of rendered) {
    if (rendered.get(n) === 'wip') continue;
    if (Math.abs(n - CUR) > keep) {
      const s = slots.get(n);
      if (s) { s.innerHTML = ''; const ph = document.createElement('div'); ph.className = 'ph'; ph.textContent = n; s.appendChild(ph); }
      rendered.delete(n);
    }
  }
}

function updateCurFromScroll() {
  const vr = vp.getBoundingClientRect();
  const mid = vr.top + vr.height * 0.3;
  let best = 1, bestD = Infinity;
  for (const [n, s] of slots) {
    const r = s.getBoundingClientRect();
    const d = Math.abs(r.top + r.height/2 - mid);
    if (d < bestD) { bestD = d; best = n; }
  }
  if (best !== CUR) { CUR = best; updatePL(CUR); ps.value = CUR; debounceSave(); }
}

let saveT = null;
function debounceSave() { clearTimeout(saveT); saveT = setTimeout(() => { if (DOC_ID) savePage(DOC_ID, CUR); }, 1000); }
async function savePage(id, p) {
  try { const d = await dbGet('docs', id); if (d) { d.lastPage = p; d.lastOpened = Date.now(); await dbPut('docs', d); } } catch(e) {}
}

async function scrollTo(n, smooth = true) {
  const s = slots.get(n); if (!s) return;
  // Force-render the target page if not yet rendered (fixes TOC blank page bug)
  if (!rendered.has(n) || rendered.get(n) === 'wip') {
    await renderPage(n);
    // Also render neighbors
    for (let b = 1; b <= BUFFER; b++) {
      if (n+b <= TOTAL) renderPage(n+b);
      if (n-b >= 1) renderPage(n-b);
    }
  }
  const th = CHROME ? 52 : 0;
  vp.scrollTo({ top: s.offsetTop - th - 4, behavior: smooth ? 'smooth' : 'auto' });
  CUR = n; updatePL(n);
}

// ================================================
// HIGHLIGHT SYSTEM
// ================================================
function buildHighlightOverlay(pageNum, canvas) {
  const pageHls = highlights.filter(h => h.page === pageNum);
  if (!pageHls.length) return null;
  const ov = document.createElement('div');
  ov.className = 'hl-ov';
  for (const hl of pageHls) {
    for (const r of hl.rects) {
      const el = document.createElement('div');
      el.className = 'hl-r hl-' + hl.color;
      el.style.left = (r.x * 100) + '%';
      el.style.top = (r.y * 100) + '%';
      el.style.width = (r.w * 100) + '%';
      el.style.height = (r.h * 100) + '%';
      ov.appendChild(el);
    }
  }
  return ov;
}

async function loadHighlights() {
  if (!DOC_ID || !db) { highlights = []; return; }
  try {
    // Check if highlights store exists
    if (!db.objectStoreNames.contains('highlights')) { highlights = []; return; }
    highlights = await dbIdx('highlights', 'docId', DOC_ID);
  } catch(e) { console.warn('Failed to load highlights:', e); highlights = []; }
}

async function saveHighlight(page, text, rects, color) {
  if (!DOC_ID || !db || !db.objectStoreNames.contains('highlights')) {
    showToast('Cannot save highlight — reset cache and try again');
    return;
  }
  const hl = {
    id: 'hl_' + Date.now() + '_' + Math.random().toString(36).slice(2,6),
    docId: DOC_ID, page, text: text.substring(0, 500),
    rects, color: color || 'yellow', createdAt: Date.now(),
    note: ''
  };
  await dbPut('highlights', hl);
  highlights.push(hl);
  hlUndoStack.push(hl.id);
  if (typeof updateUndoBtn === 'function') updateUndoBtn();
  refreshHighlightsOnPage(page);
  showToast('Highlighted');
  // Show annotation modal
  pendingAnnotationId = hl.id;
  annPreview.textContent = hl.text;
  annInput.value = '';
  annModal.classList.add('on');
  setTimeout(() => annInput.focus(), 200);
}

async function updateHighlightNote(id, note) {
  const hl = highlights.find(h => h.id === id);
  if (!hl) return;
  hl.note = note;
  await dbPut('highlights', hl);
  showToast('Note saved');
}

async function deleteHighlight(id) {
  await dbDel('highlights', id);
  const hl = highlights.find(h => h.id === id);
  highlights = highlights.filter(h => h.id !== id);
  if (hl) refreshHighlightsOnPage(hl.page);
}

function refreshHighlightsOnPage(page) {
  const slot = slots.get(page);
  if (!slot || !rendered.has(page) || rendered.get(page) === 'wip') return;
  const canvas = slot.querySelector('canvas');
  if (!canvas) return;
  // Remove old overlay
  slot.querySelector('.hl-ov')?.remove();
  // Add updated overlay before text layer
  const hlOv = buildHighlightOverlay(page, canvas);
  if (hlOv) {
    const tl = slot.querySelector('.tl');
    if (tl) slot.insertBefore(hlOv, tl);
    else slot.appendChild(hlOv);
  }
}

// Highlights panel
function toggleHighlights() {
  const isOpen = hp.classList.contains('on');
  if (isOpen) { hp.classList.remove('on'); hpOv.classList.remove('on'); return; }
  renderHighlightsPanel();
  hp.classList.add('on'); hpOv.classList.add('on');
}

function closeHighlights() { hp.classList.remove('on'); hpOv.classList.remove('on'); }

function renderHighlightsPanel() {
  const sorted = [...highlights].sort((a, b) => a.page - b.page);
  if (!sorted.length) {
    hlList.innerHTML = '<div class="hl-empty">No highlights yet.<br>Select text and tap Highlight to save.</div>';
    return;
  }
  hlList.innerHTML = '';
  const colors = { yellow: '#FFDC50', blue: '#64A0FF', green: '#64D278', pink: '#FF8CAA' };
  for (const hl of sorted) {
    const el = document.createElement('div');
    el.className = 'hl-item';
    let noteHtml = '';
    if (hl.note) {
      noteHtml = `<div class="hl-note">${esc(hl.note)}</div>`;
    }
    noteHtml += `<div class="hl-note-edit">${hl.note ? 'Edit note' : '+ Add note'}</div>`;
    el.innerHTML = `<div class="hl-dot" style="background:${colors[hl.color] || colors.yellow}"></div><div class="hl-body"><div class="hl-text">${esc(hl.text)}</div>${noteHtml}<div class="hl-meta">Page ${hl.page} · ${timeAgo(hl.createdAt)}</div></div><button class="hl-del" title="Delete">✕</button>`;
    el.onclick = e => {
      if (e.target.closest('.hl-del')) return;
      if (e.target.closest('.hl-note-edit')) {
        // Open annotation modal for editing
        pendingAnnotationId = hl.id;
        annPreview.textContent = hl.text;
        annInput.value = hl.note || '';
        annModal.classList.add('on');
        setTimeout(() => annInput.focus(), 200);
        return;
      }
      scrollTo(hl.page); closeHighlights();
    };
    el.querySelector('.hl-del').onclick = async e => {
      e.stopPropagation();
      await deleteHighlight(hl.id);
      renderHighlightsPanel();
    };
    hlList.appendChild(el);
  }
}

function esc(s) { return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;'); }
function timeAgo(ts) {
  const d = Date.now() - ts;
  if (d < 60000) return 'just now'; if (d < 3600000) return Math.floor(d / 60000) + 'm ago';
  if (d < 86400000) return Math.floor(d / 3600000) + 'h ago'; if (d < 2592000000) return Math.floor(d / 86400000) + 'd ago';
  return new Date(ts).toLocaleDateString();
}

// Export highlights
function highlightsToMarkdown() {
  const sorted = [...highlights].sort((a, b) => a.page - b.page);
  if (!sorted.length) return '';
  let md = `# Highlights: ${document.querySelector('.tb-t')?.textContent || 'Document'}\n\n`;
  let lastPage = -1;
  for (const hl of sorted) {
    if (hl.page !== lastPage) { md += `## Page ${hl.page}\n\n`; lastPage = hl.page; }
    md += `> ${hl.text}\n\n`;
    if (hl.note) md += `**Note:** ${hl.note}\n\n`;
  }
  return md;
}

function highlightsToNotion() {
  const sorted = [...highlights].sort((a, b) => a.page - b.page);
  if (!sorted.length) return '';
  const docName = DOC_ID ? (document.querySelector('.tb-t')?.textContent || 'Document') : 'Document';
  let text = `📖 ${docName}\n\n`;
  let lastPage = -1;
  for (const hl of sorted) {
    if (hl.page !== lastPage) { text += `📄 Page ${hl.page}\n`; lastPage = hl.page; }
    const colorEmoji = { yellow: '🟡', blue: '🔵', green: '🟢', pink: '🔴' };
    text += `${colorEmoji[hl.color] || '🟡'} ${hl.text}\n`;
    if (hl.note) text += `   📝 ${hl.note}\n`;
    text += '\n';
  }
  return text;
}

function showToast(msg) {
  let t = document.getElementById('toast-el');
  if (!t) { t = document.createElement('div'); t.id = 'toast-el'; t.style.cssText = 'position:fixed;bottom:80px;left:50%;transform:translateX(-50%) translateY(20px);background:var(--text);color:var(--surface);padding:10px 20px;border-radius:10px;font:500 14px DM Sans,sans-serif;opacity:0;transition:opacity .25s,transform .25s;z-index:999;pointer-events:none'; document.body.appendChild(t); }
  t.textContent = msg; t.style.opacity = '1'; t.style.transform = 'translateX(-50%) translateY(0)';
  setTimeout(() => { t.style.opacity = '0'; t.style.transform = 'translateX(-50%) translateY(20px)'; }, 1800);
}

// ================================================
// HIGHLIGHTER MODE
// ================================================
const hlbar = $('hlbar');
const btnHLMode = $('btn-hlmode');
const btnUndo = $('btn-undo');
const btnUndo2 = $('btn-undo2');

// Color picker in floating bar
document.querySelectorAll('[data-hmc]').forEach(b => {
  b.onclick = e => {
    e.stopPropagation();
    document.querySelectorAll('[data-hmc]').forEach(x => x.classList.remove('hm-a'));
    b.classList.add('hm-a');
    hlColor = b.dataset.hmc;
    // Sync context menu colors too
    document.querySelectorAll('[data-hc]').forEach(x => x.classList.toggle('cc-a', x.dataset.hc === hlColor));
  };
});

function toggleHLMode() {
  hlModeActive = !hlModeActive;
  btnHLMode.classList.toggle('active', hlModeActive);
  hlbar.classList.toggle('on', hlModeActive);
  vp.classList.toggle('hl-active', hlModeActive);
  if (hlModeActive) {
    if (zoomLevel > 1) resetZoom();
    showToast('Highlighter ON — drag over text');
  }
}

btnHLMode.onclick = toggleHLMode;

// Undo
function undoHighlight() {
  if (!hlUndoStack.length) return;
  const lastId = hlUndoStack.pop();
  deleteHighlight(lastId);
  updateUndoBtn();
  showToast('Highlight removed');
}

function updateUndoBtn() {
  const has = hlUndoStack.length > 0;
  btnUndo.disabled = !has;
  btnUndo2.disabled = !has;
}

btnUndo.onclick = undoHighlight;
btnUndo2.onclick = undoHighlight;

// ================================================
// TOUCH-DRAG HIGHLIGHTING
// ================================================
let hlDragging = false;
let hlTouchSlot = null;
let hlTouchedSpans = new Set();
let hlPreviewEl = null;
let hlAllSpans = []; // all spans on the page, sorted by position
let hlAnchorIdx = -1; // index of first-touched span in hlAllSpans
let hlDidDrag = false; // distinguish tap from drag
let hlTouchStartPos = null; // track if finger moved

vp.addEventListener('touchstart', e => {
  if (!hlModeActive || MODE !== 'scroll') return;
  const touch = e.touches[0];
  const slot = findSlotAtPoint(touch.clientX, touch.clientY);
  if (!slot) return;

  e.preventDefault();
  hlDragging = true;
  hlTouchSlot = slot;
  hlTouchedSpans.clear();
  hlDidDrag = false;
  hlTouchStartPos = { x: touch.clientX, y: touch.clientY };

  // Get all spans on this page sorted by position
  const tl = slot.querySelector('.tl');
  if (!tl) return;
  hlAllSpans = [...tl.querySelectorAll('span')].sort((a, b) => {
    const ar = a.getBoundingClientRect(), br = b.getBoundingClientRect();
    const dy = ar.top - br.top;
    return Math.abs(dy) > 5 ? dy : ar.left - br.left;
  });

  // Find which span the finger hit
  hlAnchorIdx = findSpanIndexAtPoint(touch.clientX, touch.clientY);

  // Create preview overlay
  hlPreviewEl = document.createElement('div');
  hlPreviewEl.className = 'hl-preview';
  hlPreviewEl.style.cssText = 'position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;z-index:3';
  slot.appendChild(hlPreviewEl);

  if (hlAnchorIdx >= 0) {
    hlTouchedSpans.add(hlAllSpans[hlAnchorIdx]);
    updatePreview();
  }
}, { passive: false });

vp.addEventListener('touchmove', e => {
  if (!hlDragging || !hlTouchSlot) return;
  e.preventDefault();
  const touch = e.touches[0];

  // Check if finger actually moved (distinguish from tap)
  if (hlTouchStartPos) {
    const dx = touch.clientX - hlTouchStartPos.x;
    const dy = touch.clientY - hlTouchStartPos.y;
    if (Math.sqrt(dx*dx + dy*dy) > 10) hlDidDrag = true;
  }

  if (hlDidDrag && hlAnchorIdx >= 0) {
    // Range fill: select all spans between anchor and current position
    const curIdx = findSpanIndexAtPoint(touch.clientX, touch.clientY);
    if (curIdx >= 0) {
      hlTouchedSpans.clear();
      const start = Math.min(hlAnchorIdx, curIdx);
      const end = Math.max(hlAnchorIdx, curIdx);
      for (let i = start; i <= end; i++) {
        hlTouchedSpans.add(hlAllSpans[i]);
      }
      updatePreview();
    }
  }
}, { passive: false });

vp.addEventListener('touchend', e => {
  if (!hlDragging) return;
  hlDragging = false;

  // If it was a tap (not a drag), expand to sentence boundaries
  if (!hlDidDrag && hlAnchorIdx >= 0) {
    expandToSentence(hlAnchorIdx);
  }

  // Commit the highlight
  if (hlTouchedSpans.size > 0 && hlTouchSlot) {
    const canvas = hlTouchSlot.querySelector('canvas');
    const pageNum = +hlTouchSlot.dataset.p;
    if (canvas && pageNum) {
      const cr = canvas.getBoundingClientRect();
      const text = collectText();
      const rects = computeRects(cr);
      if (rects.length && text) {
        saveHighlight(pageNum, text, rects, hlColor);
      }
    }
  }

  // Cleanup
  if (hlPreviewEl) { hlPreviewEl.remove(); hlPreviewEl = null; }
  hlTouchSlot = null;
  hlTouchedSpans.clear();
  hlAllSpans = [];
  hlAnchorIdx = -1;
  hlTouchStartPos = null;
}, { passive: true });

function findSpanIndexAtPoint(clientX, clientY) {
  // Find the closest span to the touch point
  const tolerance = 12;
  let bestIdx = -1, bestDist = Infinity;
  for (let i = 0; i < hlAllSpans.length; i++) {
    const r = hlAllSpans[i].getBoundingClientRect();
    // Check if point is within expanded bounds
    if (clientX >= r.left - tolerance && clientX <= r.right + tolerance &&
        clientY >= r.top - tolerance && clientY <= r.bottom + tolerance) {
      // Distance to center of span
      const cx = r.left + r.width/2, cy = r.top + r.height/2;
      const d = Math.sqrt((clientX-cx)**2 + (clientY-cy)**2);
      if (d < bestDist) { bestDist = d; bestIdx = i; }
    }
  }
  return bestIdx;
}

function expandToSentence(anchorIdx) {
  // Expand selection from the anchor span outward to sentence boundaries
  // Sentence ends: . ? ! followed by space or end of text, or paragraph break (large Y gap)
  const sentenceEnd = /[.?!]["'\u201D\u2019)]*\s*$/;
  const sentenceStart = /^[\s]*[A-Z\u201C\u2018"'(]/;

  hlTouchedSpans.clear();
  hlTouchedSpans.add(hlAllSpans[anchorIdx]);

  // Expand backwards to find sentence start
  let startIdx = anchorIdx;
  for (let i = anchorIdx - 1; i >= 0; i--) {
    const span = hlAllSpans[i];
    const text = span.textContent;
    // Check for large Y gap (paragraph break)
    const curR = hlAllSpans[i+1].getBoundingClientRect();
    const prevR = span.getBoundingClientRect();
    if (Math.abs(prevR.top - curR.top) > curR.height * 1.8) break;
    // Check if previous span ends a sentence
    if (sentenceEnd.test(text)) break;
    startIdx = i;
  }

  // Expand forwards to find sentence end
  let endIdx = anchorIdx;
  for (let i = anchorIdx; i < hlAllSpans.length; i++) {
    const span = hlAllSpans[i];
    const text = span.textContent;
    endIdx = i;
    // Check if this span ends a sentence
    if (sentenceEnd.test(text)) break;
    // Check for large Y gap to next span (paragraph break)
    if (i + 1 < hlAllSpans.length) {
      const curR = span.getBoundingClientRect();
      const nextR = hlAllSpans[i+1].getBoundingClientRect();
      if (Math.abs(nextR.top - curR.top) > curR.height * 1.8) break;
    }
  }

  // Select all spans in range
  for (let i = startIdx; i <= endIdx; i++) {
    hlTouchedSpans.add(hlAllSpans[i]);
  }
  updatePreview();
}

function findSlotAtPoint(x, y) {
  // Find which page slot the touch is over
  for (const [n, s] of slots) {
    if (!rendered.has(n) || rendered.get(n) === 'wip') continue;
    const r = s.getBoundingClientRect();
    if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom) return s;
  }
  return null;
}

function collectText() {
  // Sort spans by position (top then left) and join text with smart spacing
  const sorted = [...hlTouchedSpans].sort((a, b) => {
    const ar = a.getBoundingClientRect(), br = b.getBoundingClientRect();
    const dy = ar.top - br.top;
    return Math.abs(dy) > 5 ? dy : ar.left - br.left;
  });
  let result = '';
  for (let i = 0; i < sorted.length; i++) {
    const txt = sorted[i].textContent;
    if (i > 0) {
      // Add space between spans if the previous didn't end with space and current doesn't start with space
      const prev = result;
      if (prev.length && !prev.endsWith(' ') && !prev.endsWith('-') && !txt.startsWith(' ')) {
        result += ' ';
      }
    }
    result += txt;
  }
  return result.trim();
}

function computeRects(canvasRect) {
  // Group spans by line (similar Y), compute rect per line
  const sorted = [...hlTouchedSpans].sort((a, b) => {
    const ar = a.getBoundingClientRect(), br = b.getBoundingClientRect();
    const dy = ar.top - br.top;
    return Math.abs(dy) > 5 ? dy : ar.left - br.left;
  });

  const cw = canvasRect.width, ch = canvasRect.height;
  const lines = [];
  let curLine = null;

  for (const sp of sorted) {
    const r = sp.getBoundingClientRect();
    if (!curLine || Math.abs(r.top - curLine.top) > 5) {
      curLine = { top: r.top, bottom: r.bottom, left: r.left, right: r.right };
      lines.push(curLine);
    } else {
      curLine.left = Math.min(curLine.left, r.left);
      curLine.right = Math.max(curLine.right, r.right);
      curLine.top = Math.min(curLine.top, r.top);
      curLine.bottom = Math.max(curLine.bottom, r.bottom);
    }
  }

  return lines.map(l => ({
    x: (l.left - canvasRect.left) / cw,
    y: (l.top - canvasRect.top) / ch,
    w: (l.right - l.left) / cw,
    h: (l.bottom - l.top) / ch
  }));
}

function updatePreview() {
  if (!hlPreviewEl || !hlTouchSlot) return;
  hlPreviewEl.innerHTML = '';
  const canvas = hlTouchSlot.querySelector('canvas');
  if (!canvas) return;
  const cr = canvas.getBoundingClientRect();
  const rects = computeRects(cr);
  const colorMap = { yellow: 'rgba(255,220,80,.4)', blue: 'rgba(100,160,255,.35)', green: 'rgba(100,210,120,.35)', pink: 'rgba(255,140,170,.35)' };

  for (const r of rects) {
    const el = document.createElement('div');
    el.className = 'hl-preview-rect';
    el.style.left = (r.x * 100) + '%';
    el.style.top = (r.y * 100) + '%';
    el.style.width = (r.w * 100) + '%';
    el.style.height = (r.h * 100) + '%';
    el.style.background = colorMap[hlColor] || colorMap.yellow;
    hlPreviewEl.appendChild(el);
  }
}

// ================================================
// REFLOW MODE
// ================================================
async function setupReflow(start) {
  vp.style.display = 'none'; rc.classList.add('on');
  rf.innerHTML = '<div style="text-align:center;padding:40px;color:var(--text2);font-size:14px">Extracting text...</div>';
  $('s-font').style.display = ''; $('s-size').style.display = '';

  rf.innerHTML = '';
  for (let i = 1; i <= TOTAL; i++) {
    try {
      const page = await PDF.getPage(i);
      const tc = await page.getTextContent();
      const div = document.createElement('div');
      div.className = 'rp'; div.dataset.p = i; div.id = 'rp-' + i;

      let para = '', lastY = null;
      for (const item of tc.items) {
        const y = item.transform[5];
        if (lastY !== null && Math.abs(y - lastY) > 2) {
          if (para.trim() && Math.abs(y - lastY) > 15) {
            const p = document.createElement('p'); p.textContent = para.trim(); div.appendChild(p); para = '';
          } else para += ' ';
        }
        para += item.str; lastY = y;
      }
      if (para.trim()) { const p = document.createElement('p'); p.textContent = para.trim(); div.appendChild(p); }
      txtCache.set(i, tc.items.map(x => x.str).join(' '));
      rf.appendChild(div);
      if (i % 10 === 0) { setLP(Math.round(i/TOTAL*100)); await new Promise(r => setTimeout(r, 0)); }
    } catch(e) {}
  }
  applyReflow();

  rc.onscroll = () => {
    requestAnimationFrame(() => {
      const rect = rc.getBoundingClientRect();
      const pages = rf.querySelectorAll('.rp');
      for (const p of pages) {
        if (p.getBoundingClientRect().bottom > rect.top + 50) {
          const n = parseInt(p.dataset.p);
          if (n !== CUR) { CUR = n; updatePL(n); ps.value = n; }
          break;
        }
      }
    });
  };
  rc.onclick = tapToggle;
}

function applyReflow() {
  rf.style.fontFamily = getComputedStyle(document.documentElement).getPropertyValue('--rfont');
  rf.style.fontSize = getComputedStyle(document.documentElement).getPropertyValue('--rsize');
  rf.style.lineHeight = getComputedStyle(document.documentElement).getPropertyValue('--rline');
}

// ================================================
// CHROME TOGGLE
// ================================================
function tapToggle(e) {
  if (hlModeActive) return;
  if (window.getSelection()?.toString()) return;
  if (e.target.closest('button, input, a, .cm, .ann-modal')) return;

  const now = Date.now();
  const x = e.clientX || (e.changedTouches && e.changedTouches[0]?.clientX) || 0;
  const y = e.clientY || (e.changedTouches && e.changedTouches[0]?.clientY) || 0;

  // Double-tap detection (within 350ms and 40px)
  if (MODE === 'scroll' && now - lastTapTime < 350 && Math.abs(x - lastTapX) < 40 && Math.abs(y - lastTapY) < 40) {
    // Double-tap: toggle zoom
    lastTapTime = 0; // reset to prevent triple-tap
    if (zoomLevel > 1) {
      resetZoom();
    } else {
      setZoom(2.5, x, y);
    }
    return;
  }

  lastTapTime = now;
  lastTapX = x;
  lastTapY = y;

  // Single tap: toggle chrome (delayed to check for double-tap)
  // But only if not zoomed in (when zoomed, taps are for panning)
  if (zoomLevel > 1) return;

  CHROME = !CHROME;
  tb.classList.toggle('h', !CHROME);
  bb.classList.toggle('h', !CHROME);
  vp.classList.toggle('full', !CHROME);
}

function updatePL(n) { pl.textContent = n + ' / ' + TOTAL; }

// ================================================
// ZOOM (PINCH + DOUBLE-TAP)
// ================================================
zoomBadge.onclick = () => resetZoom();

// Nav-back button
let navBackTimer = null;
navBackBtn.onclick = () => {
  navBack();
  if (!navHistory.length) navBackBtn.classList.remove('on');
};
function showNavBack() {
  navBackBtn.classList.add('on');
  clearTimeout(navBackTimer);
  navBackTimer = setTimeout(() => { navBackBtn.classList.remove('on'); }, 8000);
}
function hideNavBack() { navBackBtn.classList.remove('on'); clearTimeout(navBackTimer); }

function setZoom(level, centerX, centerY) {
  const prev = zoomLevel;
  zoomLevel = Math.max(zoomMin, Math.min(zoomMax, level));
  // Round to 1 decimal
  zoomLevel = Math.round(zoomLevel * 10) / 10;
  if (zoomLevel === prev) return;

  // If zooming in with a center point, adjust scroll to keep that point stable
  if (centerX !== undefined && centerY !== undefined && zoomLevel > prev) {
    const vpRect = vp.getBoundingClientRect();
    const relX = (centerX - vpRect.left + vp.scrollLeft) / prev;
    const relY = (centerY - vpRect.top + vp.scrollTop) / prev;
    requestAnimationFrame(() => {
      vp.scrollLeft = relX * zoomLevel - (centerX - vpRect.left);
      vp.scrollTop = relY * zoomLevel - (centerY - vpRect.top);
    });
  }

  pc.style.transform = zoomLevel === 1 ? '' : `scale(${zoomLevel})`;
  vp.classList.toggle('zoomed', zoomLevel > 1);

  // Show/hide badge
  if (zoomLevel > 1) {
    zoomBadge.textContent = zoomLevel.toFixed(1) + 'x';
    zoomBadge.classList.add('on');
  } else {
    zoomBadge.classList.remove('on');
  }
}

function resetZoom() {
  zoomLevel = 1;
  pc.style.transform = '';
  vp.classList.remove('zoomed');
  vp.scrollLeft = 0;
  zoomBadge.classList.remove('on');
}

// Pinch-to-zoom gesture detection on viewport
vp.addEventListener('touchstart', e => {
  if (e.touches.length === 2 && MODE === 'scroll' && !hlModeActive) {
    e.preventDefault();
    const t1 = e.touches[0], t2 = e.touches[1];
    pinchStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
    pinchStartZoom = zoomLevel;
  }
}, { passive: false });

vp.addEventListener('touchmove', e => {
  if (e.touches.length === 2 && MODE === 'scroll' && !hlModeActive) {
    e.preventDefault();
    const t1 = e.touches[0], t2 = e.touches[1];
    const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
    if (pinchStartDist > 0) {
      const scale = dist / pinchStartDist;
      const centerX = (t1.clientX + t2.clientX) / 2;
      const centerY = (t1.clientY + t2.clientY) / 2;
      setZoom(pinchStartZoom * scale, centerX, centerY);
    }
  }
}, { passive: false });

vp.addEventListener('touchend', e => {
  if (e.touches.length < 2) {
    pinchStartDist = 0;
  }
}, { passive: true });

// ================================================
// SEARCH
// ================================================
function toggleSearch() {
  const on = sp.classList.toggle('on');
  if (on) si.focus(); else { sr.innerHTML = ''; si.value = ''; sc.textContent = ''; sResults = []; sIdx = -1; }
}

async function doSearch(q) {
  if (sAbort) sAbort.x = true;
  const ab = { x: false }; sAbort = ab;
  sResults = []; sIdx = -1; sc.textContent = 'Searching...'; sr.innerHTML = '';
  const ql = q.toLowerCase();

  for (let i = 1; i <= TOTAL; i++) {
    if (ab.x) return;
    let txt = txtCache.get(i);
    if (!txt) {
      try {
        const p = await PDF.getPage(i);
        const tc = await p.getTextContent();
        txt = tc.items.map(x => x.str).join(' ');
        txtCache.set(i, txt);
      } catch(e) { continue; }
    }
    const tl = txt.toLowerCase();
    let pos = 0;
    while ((pos = tl.indexOf(ql, pos)) !== -1) {
      const ctx = txt.substring(Math.max(0, pos-30), pos + q.length + 30);
      sResults.push({ page: i, ctx });
      const item = document.createElement('div');
      item.className = 'sr-i';
      const h = escH(ctx).replace(new RegExp(escR(escH(q)), 'gi'), '<mark>$&</mark>');
      item.innerHTML = '<span class="sr-p">p.' + i + '</span>' + h;
      const idx = sResults.length - 1;
      item.onclick = () => goSR(idx);
      sr.appendChild(item);
      pos += q.length;
    }
    sc.textContent = sResults.length + ' found';
    if (i % 20 === 0) await new Promise(r => setTimeout(r, 0));
  }
  if (sResults.length === 0) sc.textContent = 'No results';
}

function goSR(i) {
  sIdx = i; const r = sResults[i]; if (!r) return;
  if (MODE === 'scroll') scrollTo(r.page, true);
  else { const el = $('rp-' + r.page); if (el) el.scrollIntoView({ behavior: 'smooth' }); }
  sc.textContent = (i+1) + ' / ' + sResults.length;
}
function sNext() { if (!sResults.length) return; sIdx = (sIdx+1) % sResults.length; goSR(sIdx); }
function sPrev() { if (!sResults.length) return; sIdx = (sIdx-1+sResults.length) % sResults.length; goSR(sIdx); }

function escH(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function escR(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); }

// ================================================
// OUTLINE
// ================================================
function toggleOutline() { op.classList.toggle('on'); oo.classList.toggle('on'); }

// Navigation history for TOC back-button
let navHistory = [];
const NAV_MAX = 30;

function navPush() {
  navHistory.push({ page: CUR, scrollTop: vp.scrollTop });
  if (navHistory.length > NAV_MAX) navHistory.shift();
}

function navBack() {
  if (!navHistory.length) return;
  const prev = navHistory.pop();
  if (MODE === 'scroll') {
    const s = slots.get(prev.page);
    if (s) {
      vp.scrollTo({ top: prev.scrollTop, behavior: 'smooth' });
      CUR = prev.page; updatePL(prev.page);
    }
  } else {
    const el = $('rp-' + prev.page);
    if (el) { el.scrollIntoView({ behavior: 'smooth' }); CUR = prev.page; updatePL(prev.page); }
  }
}

async function resolveDestPage(dest) {
  // dest is an array like [ref, /XYZ, left, top, zoom] or [ref, /Fit] etc.
  if (!dest || !Array.isArray(dest) || dest.length === 0) return null;
  const ref = dest[0];
  try {
    const idx = await PDF.getPageIndex(ref);
    if (Number.isFinite(idx) && idx >= 0 && idx < TOTAL) {
      return { page: idx + 1, dest: dest };
    }
  } catch(e) { /* ref resolution failed, try brute-force */ }

  // Fallback: if ref is a plain number (some PDFs use page indices directly)
  if (typeof ref === 'number') {
    const p = ref + 1;
    if (p >= 1 && p <= TOTAL) return { page: p, dest: dest };
  }

  return null;
}

function getDestYOffset(dest, pageNum) {
  // dest format: [ref, /type, ...params]
  // /XYZ left top zoom  — most common, use 'top'
  // /FitH top
  // /FitBH top
  // /FitR left bottom right top
  // /Fit, /FitV, /FitB, /FitBV — just go to page top
  if (!dest || dest.length < 2) return 0;
  const type = dest[1]?.name || dest[1];
  let yPdf = null;
  if ((type === 'XYZ' || type === '/XYZ') && dest.length >= 4) {
    yPdf = dest[3]; // top in PDF coords
  } else if ((type === 'FitH' || type === '/FitH' || type === 'FitBH' || type === '/FitBH') && dest.length >= 3) {
    yPdf = dest[2];
  } else if ((type === 'FitR' || type === '/FitR') && dest.length >= 6) {
    yPdf = dest[5]; // top
  }
  if (yPdf === null || yPdf === undefined || !Number.isFinite(yPdf)) return 0;
  return yPdf;
}

async function scrollToDestination(dest) {
  const resolved = await resolveDestPage(dest);
  if (!resolved) {
    showToast('Could not navigate to this section');
    return false;
  }
  const { page: pageNum, dest: fullDest } = resolved;

  if (MODE === 'scroll') {
    const slot = slots.get(pageNum);
    if (!slot) { scrollTo(pageNum, true); return true; }

    // Get the Y-offset within the page
    const yPdf = getDestYOffset(fullDest, pageNum);

    if (yPdf && yPdf > 0) {
      // Force-render the target page first (fixes blank page on TOC nav)
      if (!rendered.has(pageNum) || rendered.get(pageNum) === 'wip') {
        await renderPage(pageNum);
        for (let b = 1; b <= BUFFER; b++) {
          if (pageNum+b <= TOTAL) renderPage(pageNum+b);
          if (pageNum-b >= 1) renderPage(pageNum-b);
        }
      }
      // We need page dimensions to convert PDF coords to pixel offset
      try {
        const pg = await PDF.getPage(pageNum);
        const viewport = pg.getViewport({ scale: 1 });
        const pageHeightPdf = viewport.height;
        // PDF Y is from bottom, we need from top
        const yFromTop = pageHeightPdf - yPdf;
        const ratio = Math.max(0, Math.min(1, yFromTop / pageHeightPdf));
        // slot.offsetHeight is the rendered page height
        const pixelOffset = ratio * slot.offsetHeight;
        const th = CHROME ? 52 : 0;
        vp.scrollTo({ top: slot.offsetTop + pixelOffset - th - 4, behavior: 'smooth' });
        CUR = pageNum; updatePL(pageNum);
      } catch(e) {
        scrollTo(pageNum, true);
      }
    } else {
      scrollTo(pageNum, true);
    }
  } else {
    const el = $('rp-' + pageNum);
    if (el) el.scrollIntoView({ behavior: 'smooth' });
    CUR = pageNum; updatePL(pageNum);
  }
  return true;
}

function buildOutline(items, container, lvl = 0) {
  const list = container || ol;
  if (!container) list.innerHTML = '';
  if (!items?.length) {
    if (lvl === 0) list.innerHTML = '<div style="padding:40px 16px;text-align:center;color:var(--text2);font-size:14px">No table of contents</div>';
    return;
  }
  for (const item of items) {
    const d = document.createElement('div');
    d.className = 'oi' + (lvl > 0 ? ' i' + Math.min(lvl, 2) : '');
    d.textContent = item.title;
    d.onclick = async () => {
      try {
        let dest = item.dest;
        if (typeof dest === 'string') {
          try { dest = await PDF.getDestination(dest); }
          catch(e) { dest = null; }
        }
        if (!dest) {
          showToast('Broken link — destination not found');
          return;
        }
        navPush();
        const ok = await scrollToDestination(dest);
        if (ok) { toggleOutline(); showNavBack(); }
      } catch(e) {
        showToast('Navigation failed');
      }
    };
    list.appendChild(d);
    if (item.items?.length) buildOutline(item.items, list, lvl + 1);
  }
}

// ================================================
// BOOKMARKS SYSTEM
// ================================================
async function loadBookmarks() {
  if (!DOC_ID || !db) { bookmarks = []; return; }
  try {
    if (!db.objectStoreNames.contains('bookmarks')) { bookmarks = []; return; }
    bookmarks = await dbIdx('bookmarks', 'docId', DOC_ID);
  } catch(e) { console.warn('Failed to load bookmarks:', e); bookmarks = []; }
}

function toggleBookmarks() {
  const isOpen = bmPanel.classList.contains('on');
  if (isOpen) { closeBookmarks(); return; }
  renderBookmarksPanel();
  bmPanel.classList.add('on'); bmOv.classList.add('on');
}

function closeBookmarks() { bmPanel.classList.remove('on'); bmOv.classList.remove('on'); }

async function addBookmark() {
  if (!DOC_ID || !db || !db.objectStoreNames.contains('bookmarks')) {
    showToast('Cannot save bookmark'); return;
  }
  // Check if current page already bookmarked
  const existing = bookmarks.find(b => b.page === CUR);
  if (existing) { showToast('Page ' + CUR + ' already bookmarked'); return; }
  const bm = {
    id: 'bm_' + Date.now() + '_' + Math.random().toString(36).slice(2,6),
    docId: DOC_ID, page: CUR, scrollY: vp.scrollTop,
    name: 'Page ' + CUR, createdAt: Date.now()
  };
  await dbPut('bookmarks', bm);
  bookmarks.push(bm);
  renderBookmarksPanel();
  showToast('Bookmarked page ' + CUR);
}

async function deleteBookmark(id) {
  await dbDel('bookmarks', id);
  bookmarks = bookmarks.filter(b => b.id !== id);
}

function renderBookmarksPanel() {
  const sorted = [...bookmarks].sort((a, b) => a.page - b.page);
  if (!sorted.length) {
    bmList.innerHTML = '<div class="bm-empty">No bookmarks yet.<br>Tap + to bookmark the current page.</div>';
    return;
  }
  bmList.innerHTML = '';
  for (const bm of sorted) {
    const el = document.createElement('div');
    el.className = 'bm-item';
    el.innerHTML = '<div class="bm-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="var(--accent)" stroke="var(--accent)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/></svg></div><div class="bm-body"><div class="bm-name">' + esc(bm.name) + '</div><div class="bm-meta">Page ' + bm.page + ' \u00b7 ' + timeAgo(bm.createdAt) + '</div></div><button class="bm-del" title="Delete">\u2715</button>';
    el.onclick = e => {
      if (e.target.closest('.bm-del')) return;
      // Double-tap to rename
      if (e.target.closest('.bm-name')) {
        renameBookmarkId = bm.id;
        rnInput.value = bm.name;
        rnModal.classList.add('on');
        setTimeout(() => { rnInput.focus(); rnInput.select(); }, 200);
        return;
      }
      // Navigate to bookmark
      if (MODE === 'scroll') {
        if (bm.scrollY) {
          vp.scrollTo({ top: bm.scrollY, behavior: 'smooth' });
          CUR = bm.page; updatePL(bm.page);
        } else { scrollTo(bm.page); }
      } else {
        const rpEl = $('rp-' + bm.page);
        if (rpEl) rpEl.scrollIntoView({ behavior: 'smooth' });
        CUR = bm.page; updatePL(bm.page);
      }
      closeBookmarks();
    };
    el.querySelector('.bm-del').onclick = async e => {
      e.stopPropagation();
      await deleteBookmark(bm.id);
      renderBookmarksPanel();
      showToast('Bookmark removed');
    };
    bmList.appendChild(el);
  }
}

// ================================================
// SETTINGS
// ================================================
function toggleSettings() { stp.classList.toggle('on'); so.classList.toggle('on'); }

function setTheme(t) {
  document.body.setAttribute('data-theme', t);
  document.querySelectorAll('.tb2').forEach(b => b.classList.toggle('a', b.dataset.tv === t));
  setCfg('theme', t);
}

function setMode(m) {
  MODE = m;
  if (zoomLevel > 1) resetZoom();
  document.querySelectorAll('.mb').forEach(b => b.classList.toggle('a', b.dataset.m === m));
  $('s-font').style.display = m === 'reflow' ? '' : 'none';
  $('s-size').style.display = m === 'reflow' ? '' : 'none';
  if (PDF) { if (m === 'scroll') setupScroll(CUR); else setupReflow(CUR); }
  setCfg('mode', m);
}

function adjSize(d) {
  RSIZE = Math.max(12, Math.min(32, RSIZE + d * 2));
  document.documentElement.style.setProperty('--rsize', RSIZE + 'px');
  $('szv').textContent = RSIZE + 'px';
  applyReflow(); setCfg('rsize', RSIZE);
}

// ================================================
// LIBRARY
// ================================================
async function renderLib() {
  const docs = await dbAll('docs');
  const lib = $('lib');
  lib.querySelectorAll('.li').forEach(el => el.remove());
  lib.querySelectorAll('.storage-bar').forEach(el => el.remove());
  const emptyEl = lib.querySelector('.le');

  if (docs.length === 0) {
    if (!emptyEl) {
      lib.innerHTML = '<div class="le"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/></svg><div class="le-t">No documents yet</div><div class="le-s">Open a PDF to start reading</div></div>';
    }
    return;
  }
  if (emptyEl) emptyEl.remove();

  // Storage usage indicator
  try {
    if (navigator.storage?.estimate) {
      const est = await navigator.storage.estimate();
      const used = est.usage || 0;
      const quota = est.quota || 0;
      if (quota > 0) {
        const pct = Math.round(used / quota * 100);
        const usedMB = (used / 1024 / 1024).toFixed(0);
        const quotaMB = (quota / 1024 / 1024).toFixed(0);
        const quotaGB = (quota / 1024 / 1024 / 1024).toFixed(1);
        const bar = document.createElement('div');
        bar.className = 'storage-bar';
        const label = usedMB > 1024 ? (used/1024/1024/1024).toFixed(1) + ' GB' : usedMB + ' MB';
        const maxLabel = quotaMB > 1024 ? quotaGB + ' GB' : quotaMB + ' MB';
        bar.innerHTML = '<span class="storage-label">' + label + ' / ' + maxLabel + '</span><div class="storage-track"><div class="storage-fill' + (pct > 80 ? ' warn' : '') + '" style="width:' + Math.min(pct, 100) + '%"></div></div><span class="storage-label">' + pct + '%</span>';
        lib.insertBefore(bar, lib.firstChild);
        if (pct > 80) showToast('Storage nearly full (' + pct + '%) — consider removing documents');
      }
    }
  } catch(e) {}

  docs.sort((a, b) => (b.lastOpened || 0) - (a.lastOpened || 0));
  for (const doc of docs) {
    const item = document.createElement('div');
    item.className = 'li';

    const thumb = document.createElement('div');
    thumb.className = 'lt';
    try {
      const c = document.createElement('canvas');
      const tp = await pdfjsLib.getDocument({ data: doc.data.slice(0), ...PDF_CONF }).promise;
      const pg = await tp.getPage(1);
      const v = pg.getViewport({ scale: 0.5 });
      c.width = v.width; c.height = v.height;
      await pg.render({ canvasContext: c.getContext('2d'), viewport: v }).promise;
      thumb.appendChild(c);
      tp.destroy();
    } catch(e) { thumb.innerHTML = '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:var(--text2);font-size:12px">PDF</div>'; }

    const title = document.createElement('div');
    title.className = 'ln';
    title.textContent = doc.name.replace(/\.pdf$/i, '');

    const meta = document.createElement('div');
    meta.className = 'lm';
    meta.textContent = 'Page ' + (doc.lastPage || 1);

    // Delete button
    const del = document.createElement('button');
    del.className = 'li-del';
    del.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6L6 18M6 6l12 12"/></svg>';
    del.onclick = e => { e.stopPropagation(); delId = doc.id; ddN.textContent = doc.name; dd.classList.add('on'); };

    item.appendChild(del);
    item.appendChild(thumb);
    item.appendChild(title);
    item.appendChild(meta);
    item.onclick = () => openLib(doc.id);

    // Long press for mobile delete
    let pt = null;
    item.addEventListener('touchstart', () => { pt = setTimeout(() => item.classList.add('show-del'), 500); }, { passive: true });
    item.addEventListener('touchend', () => clearTimeout(pt));
    item.addEventListener('touchmove', () => clearTimeout(pt));

    lib.appendChild(item);
  }
}

async function openLib(id) {
  showLoad('Opening...');
  try {
    const doc = await dbGet('docs', id);
    if (!doc) { hideLoad(); return; }
    DOC_ID = id;
    const params = { data: doc.data.slice(0), ...PDF_CONF };
    PDF = await pdfjsLib.getDocument(params).promise;
    TOTAL = PDF.numPages;
    const p1 = await PDF.getPage(1);
    const v = p1.getViewport({ scale: 1 });
    RATIO = v.width / v.height;
    document.documentElement.style.setProperty('--pr', RATIO);
    try { outline = (await PDF.getOutline()) || []; buildOutline(outline); } catch(e) { outline = []; }
    await setupReader(doc.name, doc.lastPage || 1);
    doc.lastOpened = Date.now();
    await dbPut('docs', doc);
    hideLoad();
  } catch(e) {
    hideLoad();
    if (e.name === 'PasswordException') {
      const doc = await dbGet('docs', id);
      if (doc) { pendData = doc.data; pendName = doc.name; pd.classList.add('on'); pw.value = ''; pw.focus(); }
    } else alert('Could not open: ' + e.message);
  }
}

// ================================================
// CLOSE READER
// ================================================
function closeReader() {
  if (DOC_ID) savePage(DOC_ID, CUR);
  if (obs) obs.disconnect();
  if (cleanInterval) { clearInterval(cleanInterval); cleanInterval = null; }
  rendered.clear(); slots.clear(); txtCache.clear();
  highlights = []; closeHighlights();
  bookmarks = []; closeBookmarks();
  hlModeActive = false; hlUndoStack = [];
  pendingAnnotationId = null; annModal.classList.remove('on'); annInput.value = '';
  if (zoomLevel > 1) resetZoom();
  hideNavBack(); navHistory = [];
  btnHLMode.classList.remove('active');
  hlbar.classList.remove('on');
  vp.classList.remove('hl-active');
  updateUndoBtn();
  if (PDF) { PDF.destroy(); PDF = null; }
  reader.classList.remove('on');
  welcome.classList.remove('hidden');
  sp.classList.remove('on');
  op.classList.remove('on'); oo.classList.remove('on');
  stp.classList.remove('on'); so.classList.remove('on');
  renderLib();
}

// ================================================
// LOADING
// ================================================
function showLoad(t) { lx.textContent = t || 'Loading...'; lf.style.width = '0'; lo.classList.add('on'); }
function setLP(p) { lf.style.width = p + '%'; }
function hideLoad() { lo.classList.remove('on'); }

// ================================================
// INIT
// ================================================
async function init() {
  await openDB();
  const t = await getCfg('theme'); if (t) setTheme(t);
  const m = await getCfg('mode');
  if (m) { MODE = m; document.querySelectorAll('.mb').forEach(b => b.classList.toggle('a', b.dataset.m === m)); }
  const f = await getCfg('font');
  if (f) { document.documentElement.style.setProperty('--rfont', f); document.querySelectorAll('.fb').forEach(b => b.classList.toggle('a', b.dataset.f === f)); }
  const s = await getCfg('rsize');
  if (s) { RSIZE = s; document.documentElement.style.setProperty('--rsize', RSIZE + 'px'); $('szv').textContent = RSIZE + 'px'; }
  await renderLib();
}
init();
</script>
</body>
</html>
